# -*- coding: utf-8 -*-

# === Import Th∆∞ vi·ªán ===
import telebot
import json
import logging
import os
import random
import time
import threading # C·∫ßn cho /thongbao v√† x√≥a tin nh·∫Øn delay
import subprocess # <<< C·∫¶N THI·∫æT CHO L·ªÜNH SPAM >>>
import sqlite3
import requests # C·∫ßn cho c√°c API (/thoitiet, /phim, /rutgon)
import qrcode   # C·∫ßn cho l·ªánh /qr
from io import BytesIO # C·∫ßn cho l·ªánh /qr
from datetime import datetime, timedelta, date # C·∫ßn cho /time, /plan, /diemdanh
from pathlib import Path
from threading import Lock
import html # D√πng ƒë·ªÉ escape HTML entities

# === C·∫•u h√¨nh ===
# --- B·∫Øt bu·ªôc thay ƒë·ªïi ---
BOT_TOKEN = "7352828711:AAEM-kWD-A8PXrjpYKLbHAn-MRVXKMzzmK0"             # !!! THAY TOKEN BOT C·ª¶A B·∫†N !!!
ADMIN_ID = 5992662564                          # !!! THAY ID TELEGRAM ADMIN C·ª¶A B·∫†N !!!
ADMIN_USERNAME = "mnhutdznecon"          # !!! THAY USERNAME ADMIN (kh√¥ng c√≥ @) !!!
WEATHER_API_KEY = "a40c3955762a3e2ccbd83c25ece1cf5c" # !!! THAY API KEY TH·ªúI TI·∫æT !!!
TMDB_API_KEY = "2a551c919f8c5fe445096179fc184ac3"            # !!! THAY API KEY C·ª¶A TMDb !!!

# --- ƒê∆∞·ªùng d·∫´n file ---
BASE_DIR = Path(__file__).parent
DATA_FILE_PATH = BASE_DIR / "taixiu_data_telebot.json" # File d·ªØ li·ªáu game (JSON)
DB_FILE_PATH = BASE_DIR / "user_vip_data.db"          # File database VIP (SQLite)
QR_CODE_IMAGE_PATH = BASE_DIR / "vietqr_payment.png"  # File ·∫£nh QR cho /muavip (C·∫ßn t·∫°o s·∫µn)

# --- Th√¥ng tin VIP & Ng√¢n h√†ng ---
VIP_PRICE = "50K"
VIP_DURATION_DAYS = 30
BANK_NAME = "MB Bank"
ACCOUNT_NUMBER = "17363999999999" # Thay STK th·∫≠t n·∫øu c·∫ßn
ACCOUNT_NAME = "BUI MINH NHUT"    # Thay t√™n TK th·∫≠t n·∫øu c·∫ßn
MAX_VIP_DURATION_DAYS = 18250 # ~50 nƒÉm

# --- C·∫•u h√¨nh Game ---
HOUSE_EDGE_PERCENT = 5 # T·ª∑ l·ªá l·ª£i th·∫ø nh√† c√°i (%) cho T√†i X·ªâu
JACKPOT_AMOUNT = 100000000
JACKPOT_CHANCE_ONE_IN = 5000 # T·ª∑ l·ªá 1/5000 tr√∫ng Jackpot m·ªói l·∫ßn ch∆°i T√†i X·ªâu
DELETE_DELAY = 15 # Gi√¢y
CHECKIN_REWARD = 1000000
PLAY_COOLDOWN = 2 # Gi√¢y ch·ªù gi·ªØa c√°c l·∫ßn ch∆°i T√†i X·ªâu
BAUCUA_COOLDOWN = 2 # Gi√¢y ch·ªù gi·ªØa c√°c l·∫ßn ch∆°i B·∫ßu Cua
TOP_N = 10 # S·ªë l∆∞·ª£ng ng∆∞·ªùi hi·ªÉn th·ªã trong /top
BAUCUA_ITEMS = ["b·∫ßu", "cua", "t√¥m", "c√°", "g√†", "nai"]
BAUCUA_ICONS = {"b·∫ßu": "üçê", "cua": "ü¶Ä", "t√¥m": "ü¶ê", "c√°": "üêü", "g√†": "üêì", "nai": "ü¶å"}

# --- C·∫•u h√¨nh Spam SMS (N·∫øu d√πng - C·∫ßn script ngo√†i) ---
SPAM_SCRIPT_NAME = "smsv1.py" # T√™n file script spam n·∫øu c√≥
SPAM_FREE_COOLDOWN = 50 # Gi√¢y ch·ªù gi·ªØa c√°c l·∫ßn spam FREE (Cho l·ªánh /spam)
SPAM_FREE_MAX_COUNT = 5 # S·ªë l·∫ßn spam t·ªëi ƒëa m·ªói l·ªánh cho FREE (/spam)
SPAM_VIP_MAX_COUNT = 30 # S·ªë l·∫ßn spam t·ªëi ƒëa m·ªói l·ªánh cho VIP (/spamvip)
BLACKLISTED_NUMBERS = {"112", "113", "114", "115", "119", "911"} # C√°c s·ªë b·ªã c·∫•m spam
SPAM_TIMEOUT = 60 # Gi√¢y ch·ªù t·ªëi ƒëa cho script spam ch·∫°y

# === Logging ===
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# === Qu·∫£n l√Ω d·ªØ li·ªáu & Tr·∫°ng th√°i ===
data_lock = Lock()
start_time = datetime.now() # <<< Ghi l·∫°i th·ªùi ƒëi·ªÉm bot b·∫Øt ƒë·∫ßu ch·∫°y cho l·ªánh /time
last_command_time = {} # L∆∞u th·ªùi gian d√πng l·ªánh cu·ªëi c√πng c·ªßa user {user_id: {command_name: timestamp}}
allowed_vip_users = set() # Set ch·ª©a user_id c·ªßa VIP ƒëang ho·∫°t ƒë·ªông
maintenance_mode = False
MAINTENANCE_MESSAGE = "üõ†Ô∏è Bot ƒëang b·∫£o tr√¨ ƒë·ªÉ n√¢ng c·∫•p. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t!"

# === C√°c h√†m ti·ªán √≠ch ===
# ... (gi·ªØ nguy√™n c√°c h√†m ti·ªán √≠ch: format_xu, get_user_info_from_message, get_user_profile_info) ...
def format_xu(amount: int | float) -> str:
    """ƒê·ªãnh d·∫°ng s·ªë ti·ªÅn th√†nh chu·ªói c√≥ d·∫•u ch·∫•m."""
    try:
        if isinstance(amount, float) and amount.is_integer(): amount = int(amount)
        if isinstance(amount, float): amount = round(amount)
        return f"{amount:,.0f}".replace(",", ".")
    except (ValueError, TypeError):
        return str(amount)

def get_user_info_from_message(message: telebot.types.Message) -> tuple[int, str]:
    """L·∫•y user_id v√† t√™n hi·ªÉn th·ªã an to√†n t·ª´ message."""
    user = message.from_user
    user_id = user.id
    user_name = user.username or f"{user.first_name} {user.last_name or ''}".strip() or f"User_{user_id}"
    safe_user_name = html.escape(user_name)
    return user_id, safe_user_name

# --- H√†m helper l·∫•y th√¥ng tin user (cho /info) ---
def get_user_profile_info(user_id: int) -> str:
    """L·∫•y v√† ƒë·ªãnh d·∫°ng th√¥ng tin ng∆∞·ªùi d√πng t·ª´ user_id."""
    try:
        chat = bot.get_chat(user_id)
        uid = chat.id
        fname = html.escape(chat.first_name or "")
        lname = html.escape(chat.last_name or "")
        full_name = f"{fname} {lname}".strip()
        uname = chat.username
        safe_bio = "Kh√¥ng th·ªÉ l·∫•y ho·∫∑c kh√¥ng c√≥."
        try:
             maybe_bio = getattr(chat, 'bio', None)
             if maybe_bio:
                 safe_bio = html.escape(maybe_bio)
        except Exception: pass

        mention_link = f"<a href='tg://user?id={uid}'>{full_name or 'Kh√¥ng t√™n'}</a>"
        info_lines = [
            "üë§ <b>Th√¥ng tin ng∆∞·ªùi d√πng</b> üë§",
            "--------------------------",
            f"üÜî ID: <code>{uid}</code>",
            f"üìù T√™n: {mention_link}",
            f"üîó Username: @{uname}" if uname else "üîó Username: Kh√¥ng c√≥",
            f"üìú Bio: {safe_bio}"
        ]
        return "\n".join(info_lines)
    except telebot.apihelper.ApiTelegramException as e:
        error_msg = str(e).lower()
        logger.warning(f"L·ªói API khi l·∫•y th√¥ng tin user {user_id}: {e}")
        if "chat not found" in error_msg or "user not found" in error_msg:
            return f"‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng v·ªõi ID <code>{user_id}</code>."
        elif "bot can't initiate conversation" in error_msg:
             return f"‚ùå T√¥i kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu tr√≤ chuy·ªán v·ªõi ng∆∞·ªùi d√πng ID <code>{user_id}</code>."
        else:
            return f"‚ùå L·ªói API Telegram: {html.escape(str(e))}"
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi l·∫•y th√¥ng tin user {user_id}: {e}", exc_info=True)
        return f"‚ùå L·ªói kh√¥ng mong mu·ªën khi l·∫•y th√¥ng tin ID <code>{user_id}</code>."


# === Database Setup (SQLite cho VIP Users) ===
# ... (gi·ªØ nguy√™n c√°c h√†m DB: initialize_vip_database, load_vip_users_from_db, save_vip_user_to_db, delete_vip_user_from_db, get_vip_expiration_time_from_db) ...
def initialize_vip_database():
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False)
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS vip_users (
                            user_id INTEGER PRIMARY KEY,
                            expiration_time TEXT NOT NULL
                          )''')
        conn.commit(); conn.close()
        logger.info(f"ƒê√£ kh·ªüi t·∫°o/k·∫øt n·ªëi database VIP: {DB_FILE_PATH}")
    except Exception as e: logger.error(f"L·ªói kh·ªüi t·∫°o database VIP: {e}", exc_info=True)

def load_vip_users_from_db():
    global allowed_vip_users
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); conn.row_factory = sqlite3.Row
        cursor = conn.cursor(); cursor.execute('SELECT user_id, expiration_time FROM vip_users'); rows = cursor.fetchall(); conn.close()
        current_time = datetime.now(); valid_vips = set(); expired_vips_to_delete = []
        for row in rows:
            user_id = row['user_id']; exp_time_str = row['expiration_time']
            try:
                exp_time = datetime.fromisoformat(exp_time_str)
                if exp_time > current_time: valid_vips.add(user_id)
                else: expired_vips_to_delete.append(user_id)
            except (ValueError, TypeError): logger.warning(f"DB VIP: Format time l·ªói user {user_id}: {exp_time_str}")
        allowed_vip_users = valid_vips; logger.info(f"ƒê√£ load {len(allowed_vip_users)} VIP users h·ª£p l·ªá.")
        if expired_vips_to_delete:
            logger.info(f"ƒêang x√≥a {len(expired_vips_to_delete)} VIP users h·∫øt h·∫°n...")
            conn_del = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor_del = conn_del.cursor()
            cursor_del.executemany("DELETE FROM vip_users WHERE user_id = ?", [(uid,) for uid in expired_vips_to_delete])
            conn_del.commit(); conn_del.close(); logger.info(f"ƒê√£ x√≥a {len(expired_vips_to_delete)} VIP users h·∫øt h·∫°n.")
    except Exception as e: logger.error(f"L·ªói load VIP users: {e}", exc_info=True); allowed_vip_users = set()

def save_vip_user_to_db(user_id: int, duration_days: int) -> tuple[bool, datetime | str]:
    if not (0 < duration_days <= MAX_VIP_DURATION_DAYS): return False, f"S·ªë ng√†y VIP ph·∫£i t·ª´ 1 ƒë·∫øn {MAX_VIP_DURATION_DAYS}."
    try:
        current_expiration = get_vip_expiration_time_from_db(user_id); start_date = datetime.now()
        if current_expiration and current_expiration > start_date: start_date = current_expiration
        expiration_time = start_date + timedelta(days=duration_days)
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor = conn.cursor()
        cursor.execute('INSERT OR REPLACE INTO vip_users (user_id, expiration_time) VALUES (?, ?)', (user_id, expiration_time.isoformat()))
        conn.commit(); conn.close(); logger.info(f"L∆∞u/Update VIP user {user_id}, h·∫øt h·∫°n {expiration_time.isoformat()}")
        load_vip_users_from_db(); return True, expiration_time
    except OverflowError: logger.error(f"L·ªói tr√†n s·ªë khi t√≠nh ng√†y h·∫øt h·∫°n VIP cho user {user_id}, {duration_days} ng√†y."); return False, "L·ªói tr√†n s·ªë (th·ªùi gian qu√° xa)."
    except Exception as e: logger.error(f"L·ªói l∆∞u VIP user {user_id}: {e}", exc_info=True); return False, f"L·ªói DB: {e}"

def delete_vip_user_from_db(target_user_id: int) -> bool:
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor = conn.cursor()
        cursor.execute("DELETE FROM vip_users WHERE user_id = ?", (target_user_id,)); conn.commit()
        deleted_rows = cursor.rowcount; conn.close()
        if deleted_rows > 0: logger.info(f"ƒê√£ x√≥a VIP user {target_user_id}."); allowed_vip_users.discard(target_user_id); return True
        return False
    except Exception as e: logger.error(f"L·ªói x√≥a VIP user {target_user_id}: {e}", exc_info=True); return False

def get_vip_expiration_time_from_db(user_id: int) -> datetime | None:
    try:
        conn = sqlite3.connect(DB_FILE_PATH, check_same_thread=False); cursor = conn.cursor()
        cursor.execute("SELECT expiration_time FROM vip_users WHERE user_id = ?", (user_id,)); result = cursor.fetchone(); conn.close()
        if result:
            try: return datetime.fromisoformat(result[0])
            except (ValueError, TypeError): logger.warning(f"DB VIP: Format time l·ªói khi ƒë·ªçc user {user_id}: {result[0]}"); return None
        return None
    except Exception as e: logger.error(f"L·ªói query h·∫°n VIP user {user_id}: {e}", exc_info=True); return None

# === C√°c h√†m load/save/get data game (JSON) ===
# ... (gi·ªØ nguy√™n: load_game_data_sync, save_game_data_sync, get_player_data) ...
def load_game_data_sync() -> dict:
    with data_lock:
        try:
            if DATA_FILE_PATH.exists() and DATA_FILE_PATH.stat().st_size > 0:
                with open(DATA_FILE_PATH, "r", encoding="utf-8") as f: return json.load(f)
            logger.warning(f"File data game {DATA_FILE_PATH} tr·ªëng ho·∫∑c kh√¥ng t·ªìn t·∫°i. T·∫°o m·ªõi."); return {}
        except json.JSONDecodeError: logger.error(f"L·ªói gi·∫£i m√£ JSON trong file {DATA_FILE_PATH}. Tr·∫£ v·ªÅ d·ªØ li·ªáu tr·ªëng.", exc_info=True); return {}
        except Exception as e: logger.error(f"L·ªói ƒë·ªçc file {DATA_FILE_PATH}: {e}. Tr·∫£ v·ªÅ d·ªØ li·ªáu tr·ªëng.", exc_info=True); return {}

def save_game_data_sync(data: dict):
    with data_lock:
        temp_file_path = DATA_FILE_PATH.with_suffix(".json.tmp")
        try:
            with open(temp_file_path, "w", encoding="utf-8") as f: json.dump(data, f, indent=4, ensure_ascii=False)
            os.replace(temp_file_path, DATA_FILE_PATH)
        except Exception as e:
            logger.error(f"L·ªói nghi√™m tr·ªçng khi l∆∞u game data v√†o {DATA_FILE_PATH}: {e}", exc_info=True)
            if temp_file_path.exists():
                try: temp_file_path.unlink() # C·ªë g·∫Øng x√≥a file t·∫°m n·∫øu c√≥ l·ªói
                except OSError as rm_err: logger.error(f"Kh√¥ng th·ªÉ x√≥a file t·∫°m {temp_file_path} sau l·ªói l∆∞u: {rm_err}")

def get_player_data(user_id: int, user_name: str, data: dict) -> dict:
    """L·∫•y ho·∫∑c t·∫°o d·ªØ li·ªáu ng∆∞·ªùi ch∆°i trong dictionary data."""
    uid = str(user_id) # JSON keys ph·∫£i l√† string
    safe_user_name = user_name # T√™n ƒë√£ ƒë∆∞·ª£c escape t·ª´ get_user_info_from_message
    player_info = data.get(uid)

    if player_info is None:
        # T·∫°o m·ªõi n·∫øu ch∆∞a c√≥
        player_info = {
            "name": safe_user_name,
            "xu": 100000, # S·ªë xu kh·ªüi ƒë·∫ßu
            "plays": 0,
            "last_checkin_date": None
        }
        data[uid] = player_info
        logger.info(f"T·∫°o ng∆∞·ªùi ch∆°i m·ªõi: ID={uid}, T√™n='{safe_user_name}', Xu={player_info['xu']}")
    else:
        # C·∫≠p nh·∫≠t t√™n n·∫øu thay ƒë·ªïi v√† ƒë·∫£m b·∫£o c√°c key c·∫ßn thi·∫øt t·ªìn t·∫°i
        if player_info.get("name") != safe_user_name:
            logger.info(f"C·∫≠p nh·∫≠t t√™n ng∆∞·ªùi ch∆°i {uid}: '{player_info.get('name')}' -> '{safe_user_name}'")
            player_info["name"] = safe_user_name
        player_info.setdefault("xu", 0) # ƒê·∫£m b·∫£o c√≥ key 'xu', gi√° tr·ªã m·∫∑c ƒë·ªãnh 0 n·∫øu thi·∫øu
        player_info.setdefault("plays", 0) # ƒê·∫£m b·∫£o c√≥ key 'plays'
        player_info.setdefault("last_checkin_date", None) # ƒê·∫£m b·∫£o c√≥ key 'last_checkin_date'

    return player_info

# === Logic Game ===
# ... (gi·ªØ nguy√™n: roll_dice_sync, roll_baucua_sync) ...
def roll_dice_sync() -> tuple[list[int], int, str]:
    """Tung 3 x√∫c x·∫Øc cho T√†i X·ªâu."""
    dice = [random.randint(1, 6) for _ in range(3)]; total = sum(dice)
    result = "t√†i" if 11 <= total <= 18 else "x·ªâu"; return dice, total, result

def roll_baucua_sync() -> list[str]:
    """Tung 3 'x√∫c x·∫Øc' B·∫ßu Cua."""
    return random.choices(BAUCUA_ITEMS, k=3)

# === Kh·ªüi t·∫°o Bot ===
bot = telebot.TeleBot(BOT_TOKEN, parse_mode='HTML')
logger.info("TeleBot instance ƒë√£ ƒë∆∞·ª£c t·∫°o.")

# === H√†m x√≥a tin nh·∫Øn sau delay ===
# ... (gi·ªØ nguy√™n: delete_message_after_delay) ...
def delete_message_after_delay(chat_id: int, message_id: int, delay: int):
    """X√≥a tin nh·∫Øn trong m·ªôt thread ri√™ng sau m·ªôt kho·∫£ng th·ªùi gian delay."""
    def delete_task():
        try:
            time.sleep(delay)
            bot.delete_message(chat_id=chat_id, message_id=message_id)
        except telebot.apihelper.ApiTelegramException as e:
            # B·ªè qua l·ªói n·∫øu tin nh·∫Øn kh√¥ng t√¨m th·∫•y (ƒë√£ b·ªã x√≥a th·ªß c√¥ng ho·∫∑c l·ªói kh√°c)
            if "message to delete not found" in str(e).lower() or "message identifier is not specified" in str(e).lower():
                pass # L·ªói th∆∞·ªùng g·∫∑p, kh√¥ng c·∫ßn log nhi·ªÅu
            else:
                logger.warning(f"L·ªói API khi x√≥a tin nh·∫Øn {message_id} trong chat {chat_id}: {e}")
        except Exception as e:
            logger.warning(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi x√≥a tin nh·∫Øn {message_id} trong chat {chat_id}: {e}")

    if delay > 0:
        thread = threading.Thread(target=delete_task, daemon=True)
        thread.start()

# === Middleware ki·ªÉm tra b·∫£o tr√¨ ===
# ... (gi·ªØ nguy√™n: handle_maintenance) ...
@bot.message_handler(func=lambda message: maintenance_mode and message.from_user.id != ADMIN_ID)
def handle_maintenance(message: telebot.types.Message):
    """Ch·∫∑n ng∆∞·ªùi d√πng th∆∞·ªùng khi ƒëang b·∫£o tr√¨."""
    try:
        if message.text: # Ch·ªâ tr·∫£ l·ªùi tin nh·∫Øn vƒÉn b·∫£n ƒë·ªÉ tr√°nh spam l·ªói
            bot.reply_to(message, MAINTENANCE_MESSAGE)
    except Exception as e:
        logger.error(f"L·ªói g·ª≠i tin nh·∫Øn b·∫£o tr√¨ cho user {message.from_user.id}: {e}")

# === C√°c l·ªánh ADMIN ===
# ... (gi·ªØ nguy√™n c√°c l·ªánh admin: /add, /xoavip, /socam, /thongbao, /baotri, /hoantat, /cong) ...
@bot.message_handler(commands=['add'])
def add_vip_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")

    args = message.text.split()
    # /add user_id [s·ªë_ng√†y]
    if len(args) < 2 or not args[1].isdigit():
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! D√πng: <code>/add &lt;user_id&gt; [s·ªë_ng√†y]</code>\n(M·∫∑c ƒë·ªãnh l√† {VIP_DURATION_DAYS} ng√†y n·∫øu kh√¥ng nh·∫≠p s·ªë ng√†y)")

    try:
        target_user_id = int(args[1])
        duration_days = VIP_DURATION_DAYS # M·∫∑c ƒë·ªãnh
        if len(args) >= 3:
            try:
                duration_days = int(args[2])
                if not (0 < duration_days <= MAX_VIP_DURATION_DAYS):
                    return bot.reply_to(message, f"‚ö†Ô∏è S·ªë ng√†y VIP ph·∫£i l√† m·ªôt s·ªë d∆∞∆°ng v√† kh√¥ng qu√° {MAX_VIP_DURATION_DAYS} ng√†y.")
            except ValueError:
                return bot.reply_to(message, "‚ö†Ô∏è S·ªë ng√†y VIP ph·∫£i l√† m·ªôt s·ªë nguy√™n h·ª£p l·ªá.")

        success, result_data = save_vip_user_to_db(target_user_id, duration_days)

        if success and isinstance(result_data, datetime):
            exp_str = result_data.strftime('%Y-%m-%d %H:%M:%S')
            reply_msg = f"‚úÖ ƒê√£ c·∫•p/gia h·∫°n VIP th√†nh c√¥ng <b>{duration_days}</b> ng√†y cho ng∆∞·ªùi d√πng ID <code>{target_user_id}</code>.\n‚è≥ Ng√†y h·∫øt h·∫°n m·ªõi: <b>{exp_str}</b>."
            bot.reply_to(message, reply_msg)
            # Th√¥ng b√°o cho ng∆∞·ªùi d√πng ƒë∆∞·ª£c c·∫•p VIP
            try:
                bot.send_message(target_user_id, f"üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒë∆∞·ª£c qu·∫£n tr·ªã vi√™n c·∫•p/gia h·∫°n <b>{duration_days}</b> ng√†y VIP.\nüóìÔ∏è VIP c·ªßa b·∫°n s·∫Ω h·∫øt h·∫°n v√†o l√∫c: {exp_str}")
                logger.info(f"Admin {user_id} ƒë√£ c·∫•p {duration_days} ng√†y VIP cho user {target_user_id}")
            except Exception as e:
                logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn th√¥ng b√°o c·∫•p VIP cho user {target_user_id}: {e}")
                bot.reply_to(message, f"‚ÑπÔ∏è ƒê√£ c·∫•p VIP th√†nh c√¥ng nh∆∞ng kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn th√¥ng b√°o cho ng∆∞·ªùi d√πng ID <code>{target_user_id}</code> (c√≥ th·ªÉ do h·ªç ƒë√£ ch·∫∑n bot).")
        else:
            bot.reply_to(message, f"‚ùå L·ªói khi th√™m VIP cho ID <code>{target_user_id}</code>: {result_data}")
            logger.error(f"Admin {user_id} g·∫∑p l·ªói khi th√™m VIP cho {target_user_id}: {result_data}")

    except ValueError:
        bot.reply_to(message, "‚ùå User ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ID d·∫°ng s·ªë.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën trong l·ªánh /add: {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh x·ª≠ l√Ω.")

@bot.message_handler(commands=['xoavip'])
def xoavip_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y!")

    args = message.text.split()
    if len(args) != 2 or not args[1].isdigit():
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! D√πng: <code>/xoavip &lt;user_id&gt;</code>")

    try:
        target_user_id = int(args[1])
        deleted = delete_vip_user_from_db(target_user_id)

        if deleted:
            bot.reply_to(message, f"‚úÖ ƒê√£ x√≥a th√†nh c√¥ng tr·∫°ng th√°i VIP c·ªßa ng∆∞·ªùi d√πng ID <code>{target_user_id}</code>.")
            logger.info(f"Admin {user_id} ƒë√£ x√≥a VIP c·ªßa user {target_user_id}")
            # Th√¥ng b√°o cho ng∆∞·ªùi d√πng b·ªã x√≥a VIP
            try:
                bot.send_message(target_user_id, "‚ÑπÔ∏è Tr·∫°ng th√°i VIP c·ªßa b·∫°n ƒë√£ b·ªã qu·∫£n tr·ªã vi√™n thu h·ªìi.")
            except Exception as e:
                logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn th√¥ng b√°o thu h·ªìi VIP cho user {target_user_id}: {e}")
        else:
            bot.reply_to(message, f"‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng VIP v·ªõi ID <code>{target_user_id}</code> ho·∫∑c ƒë√£ c√≥ l·ªói x·∫£y ra khi x√≥a.")
            logger.warning(f"Admin {user_id} x√≥a VIP user {target_user_id} th·∫•t b·∫°i (kh√¥ng t√¨m th·∫•y ho·∫∑c l·ªói DB).")

    except ValueError:
        bot.reply_to(message, "‚ùå User ID kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ID d·∫°ng s·ªë.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën trong l·ªánh /xoavip: {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën trong qu√° tr√¨nh x·ª≠ l√Ω.")

@bot.message_handler(commands=['socam'])
def socam_command(message: telebot.types.Message):
    # L∆∞u √Ω: Danh s√°ch n√†y ch·ªâ t·ªìn t·∫°i trong b·ªô nh·ªõ, s·∫Ω m·∫•t khi bot kh·ªüi ƒë·ªông l·∫°i.
    # C·∫ßn gi·∫£i ph√°p l∆∞u tr·ªØ l√¢u d√†i (file/DB) n·∫øu mu·ªën c·∫•m vƒ©nh vi·ªÖn.
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
    args = message.text.split()
    if len(args) != 2: return bot.reply_to(message, "‚ùå Syntax: <code>/socam [SƒêT]</code>")
    phone_number = args[1].replace('+', '').replace(' ', '').strip()
    if not phone_number.isdigit(): return bot.reply_to(message, "‚ùå S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá.")
    if phone_number in BLACKLISTED_NUMBERS: return bot.reply_to(message, f"‚ÑπÔ∏è S·ªë <code>{phone_number}</code> ƒë√£ c√≥ trong danh s√°ch c·∫•m t·∫°m th·ªùi.")
    BLACKLISTED_NUMBERS.add(phone_number); logger.info(f"Admin {ADMIN_ID} th√™m s·ªë {phone_number} v√†o blacklist t·∫°m th·ªùi.")
    bot.reply_to(message, f"‚úÖ ƒê√£ th√™m s·ªë <code>{phone_number}</code> v√†o danh s√°ch c·∫•m t·∫°m th·ªùi (s·∫Ω m·∫•t khi bot restart).")

@bot.message_handler(commands=['thongbao'])
def thongbao_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")

    args = message.text.split(maxsplit=1)
    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p n·ªôi dung th√¥ng b√°o: <code>/thongbao [N·ªôi dung c·∫ßn g·ª≠i]</code>")

    broadcast_message = args[1].strip()
    game_data = load_game_data_sync()
    user_ids_str = list(game_data.keys())

    if not user_ids_str:
        return bot.reply_to(message, "‚ÑπÔ∏è Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o trong d·ªØ li·ªáu ƒë·ªÉ g·ª≠i th√¥ng b√°o.")

    total_users = len(user_ids_str)
    sent_count = 0
    failed_count = 0
    blocked_count = 0

    logger.info(f"Admin {ADMIN_ID} b·∫Øt ƒë·∫ßu g·ª≠i th√¥ng b√°o ƒë·∫øn {total_users} ng∆∞·ªùi d√πng...")
    try:
        confirm_msg = bot.reply_to(message, f"‚è≥ ƒêang chu·∫©n b·ªã g·ª≠i th√¥ng b√°o ƒë·∫øn <b>{total_users}</b> ng∆∞·ªùi d√πng...")
    except Exception as e:
        logger.error(f"L·ªói g·ª≠i tin nh·∫Øn x√°c nh·∫≠n /thongbao: {e}")
        return # Kh√¥ng th·ªÉ g·ª≠i x√°c nh·∫≠n th√¨ d·ª´ng

    def broadcast_thread_func():
        nonlocal sent_count, failed_count, blocked_count
        for user_id_str in user_ids_str:
            try:
                user_id_int = int(user_id_str)
                bot.send_message(user_id_int, broadcast_message)
                sent_count += 1
                time.sleep(0.1) # Th√™m delay nh·ªè ƒë·ªÉ tr√°nh rate limit API
            except ValueError:
                logger.warning(f"B·ªè qua ID kh√¥ng h·ª£p l·ªá trong d·ªØ li·ªáu: {user_id_str}")
                failed_count += 1
            except telebot.apihelper.ApiTelegramException as e:
                error_str = str(e).lower()
                if "forbidden: bot was blocked by the user" in error_str:
                    blocked_count += 1
                    logger.info(f"Ng∆∞·ªùi d√πng {user_id_str} ƒë√£ ch·∫∑n bot.")
                elif "chat not found" in error_str:
                    blocked_count += 1
                    logger.warning(f"Kh√¥ng t√¨m th·∫•y chat c·ªßa ng∆∞·ªùi d√πng {user_id_str} (c√≥ th·ªÉ ƒë√£ x√≥a t√†i kho·∫£n).")
                # C√≥ th·ªÉ th√™m c√°c ƒëi·ªÅu ki·ªán l·ªói kh√°c ·ªü ƒë√¢y
                else:
                    logger.warning(f"L·ªói API Telegram khi g·ª≠i th√¥ng b√°o ƒë·∫øn {user_id_str}: {e}")
                    failed_count += 1
                time.sleep(0.5) # Delay l·ªõn h∆°n n·∫øu g·∫∑p l·ªói API
            except Exception as e:
                logger.error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh khi g·ª≠i th√¥ng b√°o ƒë·∫øn {user_id_str}: {e}", exc_info=True)
                failed_count += 1
                time.sleep(0.5)

        # K·∫øt th√∫c v√≤ng l·∫∑p, g·ª≠i k·∫øt qu·∫£
        result_text = (
            f"‚úÖ <b>Th√¥ng b√°o ho√†n t·∫•t!</b>\n"
            f"--------------------------\n"
            f"‚úîÔ∏è G·ª≠i th√†nh c√¥ng: <b>{sent_count}</b>\n"
            f"‚ùå G·ª≠i th·∫•t b·∫°i: <b>{failed_count}</b>\n"
            f"üö´ B·ªã ch·∫∑n/Kh√¥ng t√¨m th·∫•y: <b>{blocked_count}</b>"
        )
        try:
            # S·ª≠a tin nh·∫Øn x√°c nh·∫≠n ban ƒë·∫ßu
            bot.edit_message_text(result_text, chat_id=confirm_msg.chat.id, message_id=confirm_msg.message_id)
        except Exception as edit_e:
            logger.error(f"L·ªói kh√¥ng th·ªÉ s·ª≠a tin nh·∫Øn k·∫øt qu·∫£ th√¥ng b√°o: {edit_e}")
            # G·ª≠i tin nh·∫Øn m·ªõi n·∫øu kh√¥ng s·ª≠a ƒë∆∞·ª£c
            bot.send_message(ADMIN_ID, result_text)

    # Ch·∫°y h√†m g·ª≠i trong m·ªôt thread ri√™ng ƒë·ªÉ kh√¥ng block bot ch√≠nh
    broadcast_thread = threading.Thread(target=broadcast_thread_func, daemon=True)
    broadcast_thread.start()

@bot.message_handler(commands=['baotri'])
def baotri_command(message: telebot.types.Message):
    global maintenance_mode
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
    maintenance_mode = True
    logger.info(f"Admin {ADMIN_ID} ƒë√£ B·∫¨T ch·∫ø ƒë·ªô b·∫£o tr√¨.")
    bot.reply_to(message, "‚úÖ ƒê√£ b·∫≠t ch·∫ø ƒë·ªô b·∫£o tr√¨. Ch·ªâ Admin m·ªõi c√≥ th·ªÉ d√πng l·ªánh.")

@bot.message_handler(commands=['hoantat'])
def hoantat_command(message: telebot.types.Message):
    global maintenance_mode
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")
    maintenance_mode = False
    logger.info(f"Admin {ADMIN_ID} ƒë√£ T·∫ÆT ch·∫ø ƒë·ªô b·∫£o tr√¨.")
    bot.reply_to(message, "‚úÖ ƒê√£ t·∫Øt ch·∫ø ƒë·ªô b·∫£o tr√¨. Bot ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng.")

@bot.message_handler(commands=['cong'])
def cong_command(message: telebot.types.Message):
    user_id, _ = get_user_info_from_message(message)
    if user_id != ADMIN_ID: return bot.reply_to(message, "‚õî B·∫°n kh√¥ng c√≥ quy·ªÅn!")

    args = message.text.split()
    target_user_id = None
    amount = None

    # /cong user_id amount
    if len(args) == 3:
        try:
            target_user_id = int(args[1])
            amount_str = args[2].replace('.', '').replace(',', '') # X√≥a d·∫•u ch·∫•m, ph·∫©y
            amount = int(amount_str)
            if amount <= 0:
                return bot.reply_to(message, "‚ùå S·ªë xu c·ªông ph·∫£i l√† s·ªë d∆∞∆°ng.")
        except ValueError:
            return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p ho·∫∑c s·ªë kh√¥ng h·ª£p l·ªá.\nD√πng: <code>/cong [user_id] [s·ªë_xu]</code>")
    else:
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! D√πng: <code>/cong [user_id] [s·ªë_xu]</code>")

    game_data = load_game_data_sync()
    # L·∫•y t√™n ƒë·ªÉ hi·ªÉn th·ªã, n·∫øu ch∆∞a c√≥ th√¨ d√πng t√™n m·∫∑c ƒë·ªãnh
    target_name_temp = game_data.get(str(target_user_id), {}).get("name", f"User_{target_user_id}")
    target_player = get_player_data(target_user_id, target_name_temp, game_data) # H√†m n√†y c≈©ng t·∫°o user n·∫øu ch∆∞a c√≥

    target_player["xu"] += amount
    save_game_data_sync(game_data) # L∆∞u l·∫°i d·ªØ li·ªáu sau khi thay ƒë·ªïi

    logger.info(f"Admin {user_id} ƒë√£ c·ªông {format_xu(amount)} xu cho {target_player['name']}(ID:{target_user_id}). S·ªë d∆∞ m·ªõi: {format_xu(target_player['xu'])}")
    bot.reply_to(message, f"‚úÖ ƒê√£ c·ªông th√†nh c√¥ng <b>{format_xu(amount)}</b> xu cho ng∆∞·ªùi d√πng {target_player['name']} (ID: <code>{target_user_id}</code>).\nüí∞ S·ªë d∆∞ m·ªõi c·ªßa h·ªç: <b>{format_xu(target_player['xu'])}</b> xu.")


# === C√°c l·ªánh Ng∆∞·ªùi d√πng ===

# --- C·∫≠p nh·∫≠t l·ªánh /start, /help ---
@bot.message_handler(commands=['start', 'help'])
def start_help_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    # ƒê·∫£m b·∫£o ng∆∞·ªùi d√πng c√≥ trong d·ªØ li·ªáu khi h·ªç /start
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    save_game_data_sync(game_data) # L∆∞u n·∫øu user m·ªõi ƒë∆∞·ª£c t·∫°o

    is_admin = user_id == ADMIN_ID
    is_vip = user_id in allowed_vip_users

    help_text = f"""
üëã Ch√†o {user_name}! S·ªë d∆∞ c·ªßa b·∫°n: üí∞ <b>{format_xu(player_data['xu'])}</b> xu.
"""
    if is_vip:
        exp_time = get_vip_expiration_time_from_db(user_id)
        if exp_time:
            help_text += f"üíé B·∫°n l√† th√†nh vi√™n <b>VIP</b> (H·∫øt h·∫°n: {exp_time.strftime('%d/%m/%Y %H:%M')})\n"
    help_text += "\nüìñ <b>L·ªánh Ng∆∞·ªùi D√πng Th∆∞·ªùng:</b>"
    help_text += """
‚îú‚îÄ /help - Xem l·ªánh
‚îú‚îÄ /muavip - üíé H∆∞·ªõng d·∫´n mua/gia h·∫°n VIP 
‚îú‚îÄ /plan - üìÖ Ki·ªÉm tra th·ªùi h·∫°n VIP c·ªßa b·∫°n
‚îú‚îÄ /diemdanh - üéÅ Nh·∫≠n xu mi·ªÖn ph√≠ m·ªói ng√†y
‚îú‚îÄ /check - üí∞ Xem s·ªë d∆∞ xu hi·ªán t·∫°i
‚îú‚îÄ /play <code>[t√†i|x·ªâu] [s·ªë_xu|all]</code> - üé≤ Ch∆°i game T√†i X·ªâu
‚îú‚îÄ /baucua <code>[v·∫≠t] [s·ªë_xu|all|10k|1m]</code> - ü¶Ä Ch∆°i game B·∫ßu Cua 
‚îú‚îÄ /top - üèÜ Xem b·∫£ng x·∫øp h·∫°ng ng∆∞·ªùi ch∆°i gi√†u nh·∫•t
‚îú‚îÄ /time - ‚è±Ô∏è Xem th·ªùi gian bot ƒë√£ ho·∫°t ƒë·ªông
‚îú‚îÄ /info <code>[reply tin nh·∫Øn / ID ng∆∞·ªùi d√πng]</code> - üë§ Xem th√¥ng tin c∆° b·∫£n c·ªßa ng∆∞·ªùi d√πng Telegram
‚îú‚îÄ /qr <code>[N·ªôi dung c·∫ßn t·∫°o QR]</code> - üßê T·∫°o m√£ QR t·ª´ vƒÉn b·∫£n
‚îú‚îÄ /rutgon <code>[Link URL c·∫ßn r√∫t g·ªçn]</code> - üîó R√∫t g·ªçn link URL d√†i
‚îú‚îÄ /thoitiet <code>[T√™n th√†nh ph·ªë/ƒë·ªãa ƒëi·ªÉm]</code> - üå¶Ô∏è Xem th√¥ng tin th·ªùi ti·∫øt
‚îú‚îÄ /phim <code>[T√™n phim c·∫ßn t√¨m]</code> - üé¨ T√¨m th√¥ng tin chi ti·∫øt v·ªÅ phim
‚îú‚îÄ /spam <code>[SƒêT] [S·ªë l∆∞·ª£ng]</code> - üì± G·ª≠i SMS free n√™n max 5 l·∫ßn v·ªõi m·ªói l·∫ßn g·ª≠i l·ªánh l√† 50s
‚îú‚îÄ /admin - üßë‚Äçüíº Li√™n h·ªá v·ªõi qu·∫£n tr·ªã vi√™n 
"""
    # Th√™m l·ªánh VIP n·∫øu ng∆∞·ªùi d√πng l√† VIP
    if is_vip:
        vip_commands_text = f"""
üíé <b>L·ªánh D√†nh Ri√™ng Cho VIP:</b>
‚îî‚îÄ /spamvip <code>[SƒêT] [S·ªë l∆∞·ª£ng]</code> - üì± G·ª≠i SMS 
"""
        help_text += vip_commands_text

    # Th√™m l·ªánh Admin n·∫øu ng∆∞·ªùi d√πng l√† Admin
    if is_admin:
        admin_commands_text = f"""
üîí <b>L·ªánh D√†nh Ri√™ng Cho Admin:</b>
‚îú‚îÄ /add <code>[id] [ng√†y]</code> - Th√™m ho·∫∑c gia h·∫°n VIP cho ng∆∞·ªùi d√πng
‚îú‚îÄ /xoavip <code>[id]</code> - X√≥a tr·∫°ng th√°i VIP c·ªßa ng∆∞·ªùi d√πng
‚îú‚îÄ /cong <code>[id] [xu]</code> - C·ªông xu v√†o t√†i kho·∫£n ng∆∞·ªùi d√πng
‚îú‚îÄ /thongbao <code>[n·ªôi dung]</code> - G·ª≠i th√¥ng b√°o ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi d√πng
‚îú‚îÄ /socam <code>[SƒêT]</code> - Th√™m SƒêT v√†o danh s√°ch ƒëen t·∫°m th·ªùi (cho l·ªánh spam)
‚îú‚îÄ /baotri - üõ†Ô∏è B·∫≠t ch·∫ø ƒë·ªô b·∫£o tr√¨ (ch·ªâ admin d√πng ƒë∆∞·ª£c bot)
‚îî‚îÄ /hoantat - ‚úÖ T·∫Øt ch·∫ø ƒë·ªô b·∫£o tr√¨
"""
        help_text += admin_commands_text

    help_text += f"\nCh√∫c b·∫°n s·ª≠ d·ª•ng bot vui v·∫ª!"
    bot.reply_to(message, help_text, disable_web_page_preview=True)

# ... (gi·ªØ nguy√™n c√°c l·ªánh ng∆∞·ªùi d√πng kh√°c: /top, /info, /muavip, /plan, /check, /diemdanh, /time, /play, /baucua, /qr, /rutgon, /thoitiet, /phim, /admin) ...
@bot.message_handler(commands=['top'])
def top_command(message: telebot.types.Message):
    """Hi·ªÉn th·ªã b·∫£ng x·∫øp h·∫°ng ng∆∞·ªùi ch∆°i theo s·ªë xu."""
    user_id, user_name = get_user_info_from_message(message)
    logger.info(f"User {user_id} ({user_name}) y√™u c·∫ßu xem /top.")

    game_data = load_game_data_sync()
    if not game_data:
        return bot.reply_to(message, "‚ÑπÔ∏è Hi·ªán t·∫°i ch∆∞a c√≥ d·ªØ li·ªáu ng∆∞·ªùi ch∆°i n√†o ƒë·ªÉ x·∫øp h·∫°ng.")

    player_list = []
    for uid_str, p_data in game_data.items():
        # Ch·ªâ th√™m v√†o danh s√°ch n·∫øu c√≥ ƒë·ªß th√¥ng tin 'xu' v√† 'name'
        if isinstance(p_data, dict) and "xu" in p_data and "name" in p_data:
             player_list.append({
                 "id": uid_str, # Gi·ªØ ID d·∫°ng string nh∆∞ trong dict g·ªëc
                 "name": p_data["name"], # T√™n ƒë√£ ƒë∆∞·ª£c escape s·∫µn
                 "xu": p_data.get("xu", 0) # L·∫•y xu, m·∫∑c ƒë·ªãnh l√† 0 n·∫øu thi·∫øu
             })
        else:
            logger.warning(f"D·ªØ li·ªáu ng∆∞·ªùi ch∆°i kh√¥ng h·ª£p l·ªá trong /top cho ID {uid_str}: {p_data}")


    if not player_list:
        return bot.reply_to(message, "‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i h·ª£p l·ªá n√†o trong d·ªØ li·ªáu.")

    # S·∫Øp x·∫øp ng∆∞·ªùi ch∆°i theo s·ªë xu gi·∫£m d·∫ßn
    # D√πng lambda function ƒë·ªÉ ch·ªâ ƒë·ªãnh s·∫Øp x·∫øp theo key 'xu'
    sorted_players = sorted(player_list, key=lambda p: p["xu"], reverse=True)

    # L·∫•y top N ng∆∞·ªùi ch∆°i ƒë·∫ßu ti√™n
    top_players = sorted_players[:TOP_N]

    # T·∫°o tin nh·∫Øn hi·ªÉn th·ªã b·∫£ng x·∫øp h·∫°ng
    reply_lines = [f"üèÜ <b>B·∫¢NG X·∫æP H·∫†NG TOP {len(top_players)} ƒê·∫†I GIA</b> üèÜ", "--------------------------"]
    ranks_emojis = ["ü•á", "ü•à", "ü•â"] # Emoji cho top 3

    for rank, player in enumerate(top_players, 1): # B·∫Øt ƒë·∫ßu rank t·ª´ 1
        rank_icon = ranks_emojis[rank-1] if rank <= len(ranks_emojis) else "üèÖ" # Icon top 3 ho·∫∑c icon th∆∞·ªùng
        safe_name = player["name"] # T√™n ƒë√£ ƒë∆∞·ª£c escape khi l∆∞u
        formatted_xu = format_xu(player["xu"])
        reply_lines.append(f"{rank_icon} {rank}. {safe_name} - üí∞ <b>{formatted_xu}</b> xu")

    reply_text = "\n".join(reply_lines)
    bot.reply_to(message, reply_text)

@bot.message_handler(commands=['info'])
def info_command(message: telebot.types.Message):
    user_id_to_check = None
    args = message.text.split()
    requesting_user_id = message.from_user.id

    # Tr∆∞·ªùng h·ª£p 1: Reply tin nh·∫Øn c·ªßa ng∆∞·ªùi kh√°c
    if message.reply_to_message:
        target_user = message.reply_to_message.from_user
        user_id_to_check = target_user.id
        logger.info(f"User {requesting_user_id} y√™u c·∫ßu /info c·ªßa user {target_user.id} (th√¥ng qua reply).")
    # Tr∆∞·ªùng h·ª£p 2: Cung c·∫•p ID ng∆∞·ªùi d√πng
    elif len(args) > 1:
        try:
            user_id_to_check = int(args[1])
            logger.info(f"User {requesting_user_id} y√™u c·∫ßu /info cho ID: {user_id_to_check}.")
        except ValueError:
            return bot.reply_to(message, "‚ùå ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p ID d·∫°ng s·ªë ho·∫∑c reply tin nh·∫Øn.")
    # Tr∆∞·ªùng h·ª£p 3: Kh√¥ng c√≥ reply, kh√¥ng c√≥ ID -> l·∫•y th√¥ng tin b·∫£n th√¢n
    else:
        user_id_to_check = message.from_user.id
        logger.info(f"User {requesting_user_id} y√™u c·∫ßu /info c·ªßa ch√≠nh m√¨nh.")

    if user_id_to_check:
        info_text = get_user_profile_info(user_id_to_check)
        bot.reply_to(message, info_text, disable_web_page_preview=True)
    else:
        # Tr∆∞·ªùng h·ª£p n√†y kh√¥ng n√™n x·∫£y ra n·∫øu logic tr√™n ƒë√∫ng
        bot.reply_to(message, "‚ùå Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ng∆∞·ªùi d√πng c·∫ßn xem th√¥ng tin.")

@bot.message_handler(commands=['muavip'])
def muavip_telebot_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    # T·∫°o n·ªôi dung chuy·ªÉn kho·∫£n duy nh·∫•t cho ng∆∞·ªùi d√πng
    transfer_content = f"NAP VIP {user_id}"

    caption_text = f"""
üíé <b>ƒêƒÉng K√Ω / Gia H·∫°n VIP</b> üíé
--------------------------
üë§ Ng∆∞·ªùi d√πng: <b>{user_name}</b> (ID: <code>{user_id}</code>)
‚ú® Quy·ªÅn l·ª£i VIP: (V√≠ d·ª•: Ch∆°i game kh√¥ng gi·ªõi h·∫°n cooldown, truy c·∫≠p l·ªánh ƒë·∫∑c bi·ªát,...)
üí∞ Ph√≠ d·ªãch v·ª•: <b>{VIP_PRICE} / {VIP_DURATION_DAYS} ng√†y</b>
--------------------------
üí≥ <b>Th√¥ng Tin Thanh To√°n:</b>
üè¶ Ng√¢n h√†ng: <b>{BANK_NAME}</b>
üî¢ S·ªë t√†i kho·∫£n: <code>{ACCOUNT_NUMBER}</code>
‚úçÔ∏è T√™n ch·ªß t√†i kho·∫£n: <b>{ACCOUNT_NAME}</b>
üí¨ N·ªôi dung chuy·ªÉn kho·∫£n: <code>{transfer_content}</code> (<b>QUAN TR·ªåNG - GHI ƒê√öNG N·ªòI DUNG N√ÄY</b>)
--------------------------
‚ö†Ô∏è <b>L∆∞u √Ω quan tr·ªçng:</b>
1Ô∏è‚É£ Chuy·ªÉn kho·∫£n ch√≠nh x√°c s·ªë ti·ªÅn v√† n·ªôi dung y√™u c·∫ßu.
2Ô∏è‚É£ Sau khi chuy·ªÉn kho·∫£n th√†nh c√¥ng, ch·ª•p l·∫°i bi√™n lai giao d·ªãch.
3Ô∏è‚É£ Nh·∫•n n√∫t 'Li√™n H·ªá Admin' b√™n d∆∞·ªõi v√† g·ª≠i bi√™n lai k√®m theo ID <code>{user_id}</code> c·ªßa b·∫°n ƒë·ªÉ Admin x√°c nh·∫≠n v√† k√≠ch ho·∫°t VIP.
‚ùì N·∫øu c√≥ b·∫•t k·ª≥ th·∫Øc m·∫Øc n√†o, vui l√≤ng nh·∫•n n√∫t 'Li√™n H·ªá Admin'.
"""
    # T·∫°o n√∫t b·∫•m Inline
    markup = telebot.types.InlineKeyboardMarkup()
    btn_contact = telebot.types.InlineKeyboardButton(text="üëâ Li√™n H·ªá Admin X√°c Nh·∫≠n", url=f"https://t.me/{ADMIN_USERNAME}")
    markup.add(btn_contact)

    try:
        # Ki·ªÉm tra xem file QR c√≥ t·ªìn t·∫°i kh√¥ng
        if not QR_CODE_IMAGE_PATH.exists():
            logger.error(f"L·ªói l·ªánh /muavip: Kh√¥ng t√¨m th·∫•y file ·∫£nh QR t·∫°i {QR_CODE_IMAGE_PATH}")
            return bot.reply_to(message, f"‚ùå L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y m√£ QR thanh to√°n. Vui l√≤ng li√™n h·ªá Admin (@{ADMIN_USERNAME}) ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£.")

        # G·ª≠i ·∫£nh QR k√®m caption v√† n√∫t b·∫•m
        with open(QR_CODE_IMAGE_PATH, 'rb') as qr_photo:
            bot.send_photo(
                message.chat.id,
                photo=qr_photo,
                caption=caption_text,
                reply_markup=markup,
                reply_to_message_id=message.message_id # Tr·∫£ l·ªùi tin nh·∫Øn g·ªëc c·ªßa ng∆∞·ªùi d√πng
            )
        logger.info(f"User {user_id} ({user_name}) ƒë√£ y√™u c·∫ßu xem th√¥ng tin /muavip.")
    except FileNotFoundError:
         logger.error(f"L·ªói FileNotFoundError khi g·ª≠i /muavip: Kh√¥ng t√¨m th·∫•y file {QR_CODE_IMAGE_PATH}")
         bot.reply_to(message, f"‚ùå L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y file QR. Vui l√≤ng li√™n h·ªá Admin.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën trong l·ªánh /muavip: {e}", exc_info=True)
        bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói khi g·ª≠i th√¥ng tin mua VIP. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c li√™n h·ªá Admin (@{ADMIN_USERNAME}).")

@bot.message_handler(commands=['plan'])
def plan_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    expiration_time = get_vip_expiration_time_from_db(user_id)
    now = datetime.now()

    if expiration_time and expiration_time > now:
        # VIP c√≤n h·∫°n
        remaining_time = expiration_time - now
        days = remaining_time.days
        seconds = remaining_time.seconds
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60

        parts = []
        if days > 0: parts.append(f"{days} ng√†y")
        if hours > 0: parts.append(f"{hours} gi·ªù")
        if minutes > 0: parts.append(f"{minutes} ph√∫t")
        # N·∫øu c√≤n d∆∞·ªõi 1 ph√∫t th√¨ hi·ªÉn th·ªã gi√¢y
        if not parts and seconds > 0 : parts.append(f"{seconds} gi√¢y")
        # N·∫øu h·∫øt h·∫°n trong t√≠ch t·∫Øc (r·∫•t hi·∫øm)
        if not parts: time_str = "s·∫Øp h·∫øt h·∫°n"
        else: time_str = ", ".join(parts)

        exp_str_formatted = expiration_time.strftime('%H:%M:%S ng√†y %d/%m/%Y')
        reply_text = (
            f"üëë {user_name}, b·∫°n ƒëang l√† th√†nh vi√™n <b>VIP</b>.\n"
            f"üóìÔ∏è Th·ªùi gian c√≤n l·∫°i: <b>~{time_str}</b>\n"
            f"‚è≥ H·∫øt h·∫°n v√†o l√∫c: {exp_str_formatted}"
        )
        bot.reply_to(message, reply_text)
        logger.info(f"User {user_id} ({user_name}) ki·ªÉm tra /plan: C√≤n h·∫°n VIP ƒë·∫øn {exp_str_formatted}")

    elif expiration_time and expiration_time <= now:
        # VIP ƒë√£ h·∫øt h·∫°n
        exp_str_formatted = expiration_time.strftime('%d/%m/%Y')
        reply_text = f"üò• {user_name}, g√≥i VIP c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n v√†o ng√†y {exp_str_formatted}. H√£y d√πng l·ªánh /muavip ƒë·ªÉ gia h·∫°n nh√©!"
        bot.reply_to(message, reply_text)
        logger.info(f"User {user_id} ({user_name}) ki·ªÉm tra /plan: VIP ƒë√£ h·∫øt h·∫°n v√†o {exp_str_formatted}.")
    else:
        # Ch∆∞a t·ª´ng l√† VIP ho·∫∑c ƒë√£ b·ªã x√≥a
        reply_text = f"‚ÑπÔ∏è {user_name}, b·∫°n hi·ªán ch∆∞a ph·∫£i l√† th√†nh vi√™n VIP. S·ª≠ d·ª•ng l·ªánh /muavip ƒë·ªÉ xem h∆∞·ªõng d·∫´n ƒëƒÉng k√Ω."
        bot.reply_to(message, reply_text)
        logger.info(f"User {user_id} ({user_name}) ki·ªÉm tra /plan: Ch∆∞a ph·∫£i l√† VIP.")

@bot.message_handler(commands=['check'])
def check_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    # Kh√¥ng c·∫ßn save l·∫°i v√¨ get_player_data ch·ªâ ƒë·ªçc ho·∫∑c t·∫°o n·∫øu ch∆∞a c√≥
    bot.reply_to(message, f"üí∞ {user_name}, s·ªë d∆∞ hi·ªán t·∫°i c·ªßa b·∫°n l√†: <b>{format_xu(player_data['xu'])}</b> xu.")

@bot.message_handler(commands=['diemdanh'])
def diemdanh_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    today_str = date.today().isoformat() # L·∫•y ng√†y hi·ªán t·∫°i d∆∞·ªõi d·∫°ng 'YYYY-MM-DD'
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)

    # Ki·ªÉm tra xem ƒë√£ ƒëi·ªÉm danh h√¥m nay ch∆∞a
    if player_data.get("last_checkin_date") == today_str:
        return bot.reply_to(message, f"üóìÔ∏è {user_name}, b·∫°n ƒë√£ ƒëi·ªÉm danh ng√†y h√¥m nay r·ªìi. H√£y quay l·∫°i v√†o ng√†y mai nh√©!")

    # Ch∆∞a ƒëi·ªÉm danh -> C·ªông th∆∞·ªüng v√† c·∫≠p nh·∫≠t ng√†y
    player_data["xu"] += CHECKIN_REWARD
    player_data["last_checkin_date"] = today_str
    save_game_data_sync(game_data) # L∆∞u l·∫°i d·ªØ li·ªáu

    logger.info(f"User {user_id} ({user_name}) th·ª±c hi·ªán /diemdanh (+{CHECKIN_REWARD}). Ng√†y: {today_str}")
    bot.reply_to(message, f"‚úÖ ƒêi·ªÉm danh ng√†y {date.today().strftime('%d/%m/%Y')} th√†nh c√¥ng!\nüéÅ B·∫°n nh·∫≠n ƒë∆∞·ª£c <b>{format_xu(CHECKIN_REWARD)}</b> xu.\nüí∞ S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu.")

@bot.message_handler(commands=['time'])
def time_command(message: telebot.types.Message):
    now = datetime.now()
    uptime_delta = now - start_time # start_time ƒë∆∞·ª£c ghi l·∫°i khi bot kh·ªüi ƒë·ªông
    total_seconds = int(uptime_delta.total_seconds())

    days = total_seconds // (24 * 3600)
    seconds_remaining = total_seconds % (24 * 3600)
    hours = seconds_remaining // 3600
    seconds_remaining %= 3600
    minutes = seconds_remaining // 60
    seconds = seconds_remaining % 60

    uptime_parts = []
    if days > 0: uptime_parts.append(f"{days} ng√†y")
    if hours > 0: uptime_parts.append(f"{hours} gi·ªù")
    if minutes > 0: uptime_parts.append(f"{minutes} ph√∫t")
    if seconds > 0 or not uptime_parts: uptime_parts.append(f"{seconds} gi√¢y") # Hi·ªÉn th·ªã gi√¢y n·∫øu uptime < 1 ph√∫t

    uptime_str = ", ".join(uptime_parts)
    bot.reply_to(message, f"‚è±Ô∏è Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c: <b>{uptime_str}</b>.");
    logger.info(f"User {message.from_user.id} ({get_user_info_from_message(message)[1]}) y√™u c·∫ßu /time.")

@bot.message_handler(commands=['play'])
def play_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split()[1:] # L·∫•y c√°c ƒë·ªëi s·ªë sau /play

    # --- Ki·ªÉm tra c√∫ ph√°p ---
    if len(args) != 2:
        return bot.reply_to(message, "‚ùå Sai c√∫ ph√°p! V√≠ d·ª•:\n<code>/play t√†i 10000</code>\n<code>/play x·ªâu all</code>")

    choice = args[0].lower() # t√†i ho·∫∑c x·ªâu
    bet_input = args[1].lower() # s·ªë ti·ªÅn ho·∫∑c 'all'

    if choice not in ["t√†i", "x·ªâu"]:
        return bot.reply_to(message, "‚ùå L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn <b>t√†i</b> ho·∫∑c <b>x·ªâu</b>.")

    # --- Ki·ªÉm tra Cooldown ---
    command_name = 'play'
    current_time = time.time()
    user_last_cmd_times = last_command_time.setdefault(user_id, {}) # L·∫•y dict th·ªùi gian c·ªßa user, t·∫°o m·ªõi n·∫øu ch∆∞a c√≥
    last_play_time = user_last_cmd_times.get(command_name, 0) # L·∫•y th·ªùi gian ch∆°i l·∫ßn cu·ªëi, m·∫∑c ƒë·ªãnh 0

    if current_time - last_play_time < PLAY_COOLDOWN:
        wait_time = round(PLAY_COOLDOWN - (current_time - last_play_time), 1)
        msg_wait = bot.reply_to(message, f"‚è≥ Ch∆°i qu√° nhanh! Vui l√≤ng ch·ªù <b>{wait_time} gi√¢y</b> n·ªØa.")
        # T·ª± ƒë·ªông x√≥a tin nh·∫Øn ch·ªù v√† tin nh·∫Øn g·ªëc sau khi h·∫øt cooldown + 1s
        delete_message_after_delay(message.chat.id, msg_wait.message_id, wait_time + 1)
        delete_message_after_delay(message.chat.id, message.message_id, wait_time + 1)
        return

    # --- X·ª≠ l√Ω ti·ªÅn c∆∞·ª£c ---
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    current_xu = player_data.get("xu", 0)
    bet_amount = 0

    if bet_input == "all":
        if current_xu <= 0:
            return bot.reply_to(message, f"üò• B·∫°n ƒë√£ h·∫øt xu. H√£y /diemdanh ƒë·ªÉ nh·∫≠n th√™m nh√©!")
        bet_amount = current_xu
    else:
        try:
            bet_amount_str = bet_input.replace('.', '').replace(',', '') # X√≥a d·∫•u ngƒÉn c√°ch
            bet_amount = int(bet_amount_str)
            if bet_amount <= 0:
                 return bot.reply_to(message, "‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
        except ValueError:
            return bot.reply_to(message, "‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë ho·∫∑c 'all'.")

    # --- Ki·ªÉm tra s·ªë d∆∞ ---
    if bet_amount > current_xu:
        return bot.reply_to(message, f"üò• B·∫°n kh√¥ng ƒë·ªß <b>{format_xu(bet_amount)}</b> xu ƒë·ªÉ c∆∞·ª£c. S·ªë d∆∞ hi·ªán t·∫°i: <b>{format_xu(current_xu)}</b> xu.")

    # --- Th·ª±c hi·ªán game ---
    logger.info(f"User {user_id} ({user_name}) /play: C∆∞·ª£c {format_xu(bet_amount)} xu v√†o '{choice}'.")

    # Tr·ª´ ti·ªÅn c∆∞·ª£c tr∆∞·ªõc khi tung x√∫c x·∫Øc
    player_data["xu"] -= bet_amount
    player_data["plays"] = player_data.get("plays", 0) + 1
    user_last_cmd_times[command_name] = current_time # C·∫≠p nh·∫≠t th·ªùi gian ch∆°i cu·ªëi

    # Tung x√∫c x·∫Øc
    dice, total, result = roll_dice_sync()
    dice_str = ' + '.join(map(str, dice))
    is_win = (choice == result)
    win_amount = 0 # T·ªïng ti·ªÅn nh·∫≠n l·∫°i (bao g·ªìm c·∫£ ti·ªÅn c∆∞·ª£c g·ªëc)
    net_gain = 0   # Ti·ªÅn l√£i/l·ªó r√≤ng
    jackpot_hit = False
    jackpot_win_amount = 0

    if is_win:
        # Th·∫Øng: T√≠nh ti·ªÅn th·∫Øng d·ª±a tr√™n l·ª£i th·∫ø nh√† c√°i
        net_gain = round(bet_amount * (1 - (HOUSE_EDGE_PERCENT / 100.0))) # Ti·ªÅn l√£i = ti·ªÅn c∆∞·ª£c * (1 - t·ªâ l·ªá nh√† c√°i)
        win_amount = bet_amount + net_gain # T·ªïng nh·∫≠n l·∫°i = c∆∞·ª£c + l√£i
        player_data["xu"] += win_amount # C·ªông ti·ªÅn th·∫Øng v√†o t√†i kho·∫£n

        # Ki·ªÉm tra Jackpot
        if random.randint(1, JACKPOT_CHANCE_ONE_IN) == 1:
             jackpot_hit = True
             jackpot_win_amount = JACKPOT_AMOUNT
             player_data["xu"] += jackpot_win_amount # C·ªông ti·ªÅn Jackpot
             logger.info(f"üí• JACKPOT! User {user_id} ({user_name}) tr√∫ng {format_xu(jackpot_win_amount)} xu!")
    else:
        # Thua: M·∫•t ti·ªÅn c∆∞·ª£c
        net_gain = -bet_amount
        # Kh√¥ng c·∫ßn tr·ª´ v√¨ ƒë√£ tr·ª´ ·ªü tr∆∞·ªõc ƒë√≥

    save_game_data_sync(game_data) # L∆∞u l·∫°i d·ªØ li·ªáu ng∆∞·ªùi ch∆°i

    # --- G·ª≠i k·∫øt qu·∫£ ---
    result_icon = "üéØ" if is_win else "üí•"
    result_text = f"<b>Th·∫Øng</b>" if is_win else f"<b>Thua</b>"

    msg = (
        f"üé≤ <b>K·∫øt Qu·∫£ T√†i X·ªâu</b> üé≤\n"
        f"--------------------------\n"
        f"üë§ Ng∆∞·ªùi ch∆°i: {user_name}\n"
        f"üëá B·∫°n ch·ªçn: <b>{choice.capitalize()}</b>\n"
        f"üé≤ K·∫øt qu·∫£: <b>{dice_str} = {total} ({result.capitalize()})</b>\n"
        f"--------------------------\n"
        f"{result_icon} B·∫°n ƒë√£ {result_text}!\n"
    )
    if is_win:
        msg += f"üéâ Th·∫Øng: <b>+{format_xu(net_gain)}</b> xu\n"
    if jackpot_hit:
        # D√πng c√°ch kh√°c thay <blink>
        msg += f"<b>üíéüíéüíé N·ªî H≈® JACKPOT!!! +{format_xu(jackpot_win_amount)} xu üíéüíéüíé</b>\n"
    if not is_win:
        msg += f"üí∏ M·∫•t: <b>{format_xu(abs(net_gain))}</b> xu\n" # Hi·ªÉn th·ªã s·ªë ti·ªÅn m·∫•t (d∆∞∆°ng)

    msg += f"üí∞ S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu."

    bot.reply_to(message, msg)
    logger.info(f"/play Result: User:{user_id}, Dice:{dice}, Total:{total}, Result:{result}, Choice:{choice}, Bet:{bet_amount}, Win:{is_win}, Net:{net_gain}, Jackpot:{jackpot_hit}")


@bot.message_handler(commands=['baucua'])
def baucua_telebot_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split()[1:]

    # --- Ki·ªÉm tra c√∫ ph√°p ---
    if len(args) != 2:
        valid_items_str = ", ".join([f"{BAUCUA_ICONS.get(item, '')}<code>{item}</code>" for item in BAUCUA_ITEMS])
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! V√≠ d·ª•:\n<code>/baucua cua 10000</code>\n<code>/baucua b·∫ßu all</code>\n<code>/baucua t√¥m 10k</code>\n<code>/baucua c√° 1m</code>\nC√°c v·∫≠t ph·∫©m h·ª£p l·ªá: {valid_items_str}")

    choice = args[0].lower() # V·∫≠t ph·∫©m c∆∞·ª£c
    bet_input = args[1].lower() # S·ªë ti·ªÅn ho·∫∑c 'all', '10k', '1m'

    if choice not in BAUCUA_ITEMS:
        valid_items_str = ", ".join([f"<code>{item}</code>" for item in BAUCUA_ITEMS])
        return bot.reply_to(message, f"‚ùå V·∫≠t ph·∫©m '<code>{html.escape(choice)}</code>' kh√¥ng h·ª£p l·ªá!\nCh·ªçn m·ªôt trong c√°c v·∫≠t ph·∫©m sau: {valid_items_str}")

    # --- Ki·ªÉm tra Cooldown ---
    command_name = 'baucua'
    current_time = time.time()
    user_last_cmd_times = last_command_time.setdefault(user_id, {})
    last_baucua_time = user_last_cmd_times.get(command_name, 0)

    if current_time - last_baucua_time < BAUCUA_COOLDOWN:
        wait_time = round(BAUCUA_COOLDOWN - (current_time - last_baucua_time), 1)
        msg_wait = bot.reply_to(message, f"‚è≥ Ch∆°i qu√° nhanh! Vui l√≤ng ch·ªù <b>{wait_time} gi√¢y</b> n·ªØa.")
        delete_message_after_delay(message.chat.id, msg_wait.message_id, wait_time + 1)
        delete_message_after_delay(message.chat.id, message.message_id, wait_time + 1)
        return

    # --- X·ª≠ l√Ω ti·ªÅn c∆∞·ª£c (bao g·ªìm k, m) ---
    game_data = load_game_data_sync()
    player_data = get_player_data(user_id, user_name, game_data)
    current_xu = player_data.get("xu", 0)
    bet_amount = 0
    multiplier = 1 # H·ªá s·ªë nh√¢n (cho k, m)

    if bet_input != 'all':
        if bet_input.endswith('k'):
            multiplier = 1000
            bet_input = bet_input[:-1] # B·ªè ch·ªØ 'k'
        elif bet_input.endswith('m'):
            multiplier = 1000000
            bet_input = bet_input[:-1] # B·ªè ch·ªØ 'm'

    if bet_input == "all":
        if current_xu <= 0:
            return bot.reply_to(message, f"üò• B·∫°n ƒë√£ h·∫øt xu. H√£y /diemdanh ƒë·ªÉ nh·∫≠n th√™m nh√©!")
        bet_amount = current_xu
    else:
        try:
            bet_amount_str = bet_input.replace('.', '').replace(',', '')
            # Nh√¢n v·ªõi h·ªá s·ªë k ho·∫∑c m (n·∫øu c√≥)
            bet_amount = int(bet_amount_str) * multiplier
            if bet_amount <= 0:
                 return bot.reply_to(message, "‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0.")
        except ValueError:
            return bot.reply_to(message, "‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë, 'all', ho·∫∑c d·∫°ng 10k, 1m.")

    # --- Ki·ªÉm tra s·ªë d∆∞ ---
    if bet_amount > current_xu:
        return bot.reply_to(message, f"üò• B·∫°n kh√¥ng ƒë·ªß <b>{format_xu(bet_amount)}</b> xu ƒë·ªÉ c∆∞·ª£c. S·ªë d∆∞ hi·ªán t·∫°i: <b>{format_xu(current_xu)}</b> xu.")

    # --- Th·ª±c hi·ªán game ---
    logger.info(f"User {user_id} ({user_name}) /baucua: C∆∞·ª£c {format_xu(bet_amount)} xu v√†o '{choice}'.")

    player_data["xu"] -= bet_amount # Tr·ª´ ti·ªÅn c∆∞·ª£c
    user_last_cmd_times[command_name] = current_time # C·∫≠p nh·∫≠t th·ªùi gian ch∆°i

    # Tung x√∫c x·∫Øc B·∫ßu Cua
    results = roll_baucua_sync() # ['cua', 'b·∫ßu', 'cua']
    results_icons = [BAUCUA_ICONS.get(item, item) for item in results] # ['ü¶Ä', 'üçê', 'ü¶Ä']
    results_str_icons = " ".join(results_icons) # "ü¶Ä üçê ü¶Ä"
    results_str_text = ', '.join(results) # "cua, b·∫ßu, cua"

    # ƒê·∫øm s·ªë l·∫ßn v·∫≠t ph·∫©m c∆∞·ª£c xu·∫•t hi·ªán
    match_count = results.count(choice)
    net_gain = 0 # L√£i/l·ªó r√≤ng

    if match_count > 0:
        # Th·∫Øng: Th·∫Øng g·∫•p `match_count` l·∫ßn ti·ªÅn c∆∞·ª£c
        win_multiplier = match_count
        net_gain = bet_amount * win_multiplier # Ti·ªÅn l√£i
        player_data["xu"] += bet_amount + net_gain # C·ªông l·∫°i ti·ªÅn c∆∞·ª£c g·ªëc + ti·ªÅn l√£i
    else:
        # Thua: M·∫•t ti·ªÅn c∆∞·ª£c
        net_gain = -bet_amount
        # Kh√¥ng c·∫ßn l√†m g√¨ v√¨ ƒë√£ tr·ª´ ti·ªÅn tr∆∞·ªõc ƒë√≥

    save_game_data_sync(game_data) # L∆∞u l·∫°i d·ªØ li·ªáu

    # --- G·ª≠i k·∫øt qu·∫£ ---
    result_icon = "üéØ" if match_count > 0 else "üí•"
    result_text = f"<b>Th·∫Øng</b>" if match_count > 0 else f"<b>Thua</b>"
    choice_icon = BAUCUA_ICONS.get(choice, choice)

    msg = (
        f"ü¶Ä <b>K·∫øt Qu·∫£ B·∫ßu Cua</b> ü¶ê\n"
        f"--------------------------\n"
        f"üë§ Ng∆∞·ªùi ch∆°i: {user_name}\n"
        f"üëá B·∫°n ch·ªçn: {choice_icon} (<code>{choice}</code>)\n"
        f"üé≤ K·∫øt qu·∫£: {results_str_icons} ({results_str_text})\n"
        f"--------------------------\n"
        f"{result_icon} B·∫°n ƒë√£ {result_text}!\n"
    )
    if match_count > 0:
        msg += f"üéâ Th·∫Øng: <b>+{format_xu(net_gain)}</b> xu (xu·∫•t hi·ªán {match_count} l·∫ßn)\n"
    else:
        msg += f"üí∏ M·∫•t: <b>{format_xu(abs(bet_amount))}</b> xu\n" # Hi·ªÉn th·ªã s·ªë ti·ªÅn m·∫•t (d∆∞∆°ng)

    msg += f"üí∞ S·ªë d∆∞ m·ªõi: <b>{format_xu(player_data['xu'])}</b> xu."

    bot.reply_to(message, msg)
    logger.info(f"/baucua Result: User:{user_id}, Results:{results}, Choice:{choice}, Bet:{bet_amount}, Matches:{match_count}, Net:{net_gain}")

@bot.message_handler(commands=['qr'])
def qr_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    text_to_encode = message.text.split(maxsplit=1)

    if len(text_to_encode) < 2 or not text_to_encode[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p n·ªôi dung b·∫°n mu·ªën t·∫°o m√£ QR.\nV√≠ d·ª•: <code>/qr N·ªôi dung c·∫ßn m√£ h√≥a</code>")

    content = text_to_encode[1].strip()
    logger.info(f"User {user_id} ({user_name}) y√™u c·∫ßu t·∫°o QR cho n·ªôi dung: '{content[:50]}...'")

    try:
        # T·∫°o ƒë·ªëi t∆∞·ª£ng QRCode
        qr = qrcode.QRCode(
            version=1, # ƒê·ªô ph·ª©c t·∫°p c·ªßa QR, 1 l√† ƒë∆°n gi·∫£n nh·∫•t
            error_correction=qrcode.constants.ERROR_CORRECT_L, # M·ª©c ƒë·ªô s·ª≠a l·ªói (L=Low, M, Q, H)
            box_size=10, # K√≠ch th∆∞·ªõc m·ªói √¥ vu√¥ng trong QR
            border=4,    # ƒê·ªô d√†y vi·ªÅn tr·∫Øng xung quanh
        )
        qr.add_data(content) # Th√™m d·ªØ li·ªáu c·∫ßn m√£ h√≥a
        qr.make(fit=True)    # T·∫°o m√£ QR, t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh version n·∫øu c·∫ßn

        # T·∫°o ·∫£nh t·ª´ m√£ QR
        img = qr.make_image(fill_color="black", back_color="white")

        # L∆∞u ·∫£nh v√†o b·ªô nh·ªõ ƒë·ªám (BytesIO) ƒë·ªÉ g·ª≠i ƒëi
        img_byte_arr = BytesIO()
        img.save(img_byte_arr, format='PNG')
        img_byte_arr.seek(0) # ƒê∆∞a con tr·ªè v·ªÅ ƒë·∫ßu stream

        # Escape n·ªôi dung ƒë·ªÉ hi·ªÉn th·ªã an to√†n trong caption
        safe_caption_content = html.escape(content)
        # Gi·ªõi h·∫°n ƒë·ªô d√†i caption n·∫øu n·ªôi dung qu√° d√†i
        max_caption_len = 200
        if len(safe_caption_content) > max_caption_len:
            safe_caption_content = safe_caption_content[:max_caption_len] + "..."

        bot.send_photo(
            message.chat.id,
            photo=img_byte_arr,
            caption=f"‚ú® ƒê√¢y l√† m√£ QR c·ªßa b·∫°n cho n·ªôi dung:\n<code>{safe_caption_content}</code>",
            reply_to_message_id=message.message_id
        )
        logger.info(f"ƒê√£ t·∫°o v√† g·ª≠i QR th√†nh c√¥ng cho user {user_id}.")

    except Exception as e:
        logger.error(f"L·ªói khi t·∫°o ho·∫∑c g·ª≠i m√£ QR cho user {user_id}: {e}", exc_info=True)
        bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói khi t·∫°o m√£ QR: {html.escape(str(e))}")

@bot.message_handler(commands=['rutgon'])
def rutgon_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)

    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng cung c·∫•p link URL b·∫°n mu·ªën r√∫t g·ªçn.\nV√≠ d·ª•: <code>/rutgon https://example.com/very/long/link</code>")

    url_to_shorten = args[1].strip()

    # Ki·ªÉm tra s∆° b·ªô xem c√≥ gi·ªëng URL kh√¥ng
    if not url_to_shorten.lower().startswith(('http://', 'https://')):
        return bot.reply_to(message, "‚ùå Link kh√¥ng h·ª£p l·ªá. Link ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng <code>http://</code> ho·∫∑c <code>https://</code>.")

    logger.info(f"User {user_id} ({user_name}) y√™u c·∫ßu r√∫t g·ªçn link: {url_to_shorten}")
    api_url = "https://cleanuri.com/api/v1/shorten" # S·ª≠ d·ª•ng API c·ªßa cleanuri.com
    payload = {'url': url_to_shorten}

    try:
        # G·ª≠i y√™u c·∫ßu POST ƒë·∫øn API v·ªõi timeout 10 gi√¢y
        response = requests.post(api_url, data=payload, timeout=10)
        response.raise_for_status() # N√©m l·ªói n·∫øu status code l√† 4xx ho·∫∑c 5xx
        result = response.json() # Parse k·∫øt qu·∫£ JSON

        # Ki·ªÉm tra l·ªói t·ª´ API cleanuri
        if "error" in result:
            error_msg = result["error"]
            logger.error(f"L·ªói t·ª´ API cleanuri khi r√∫t g·ªçn '{url_to_shorten}': {error_msg}")
            return bot.reply_to(message, f"‚ùå L·ªói t·ª´ d·ªãch v·ª• r√∫t g·ªçn: {html.escape(error_msg)}")

        # L·∫•y link ƒë√£ r√∫t g·ªçn
        short_url = result.get("result_url")
        if short_url:
            reply_text = (
                f"üîó Link g·ªëc: {html.escape(url_to_shorten)}\n"
                f"‚ú® Link r√∫t g·ªçn: {short_url}"
            )
            # disable_web_page_preview=True ƒë·ªÉ Telegram kh√¥ng hi·ªÉn th·ªã preview c·ªßa link g·ªëc
            bot.reply_to(message, reply_text, disable_web_page_preview=True)
            logger.info(f"ƒê√£ r√∫t g·ªçn link '{url_to_shorten}' th√†nh c√¥ng th√†nh '{short_url}' cho user {user_id}")
        else:
            logger.error(f"API cleanuri kh√¥ng tr·∫£ v·ªÅ 'result_url' cho link '{url_to_shorten}'. Ph·∫£n h·ªìi: {result}")
            bot.reply_to(message, "‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ d·ªãch v·ª• r√∫t g·ªçn (kh√¥ng t√¨m th·∫•y link k·∫øt qu·∫£).")

    except requests.exceptions.Timeout:
        logger.error(f"Timeout khi g·ªçi API cleanuri cho link: {url_to_shorten}")
        bot.reply_to(message, "‚è≥ Y√™u c·∫ßu ƒë·∫øn d·ªãch v·ª• r√∫t g·ªçn link b·ªã qu√° th·ªùi gian. Vui l√≤ng th·ª≠ l·∫°i sau.")
    except requests.exceptions.RequestException as e:
        logger.error(f"L·ªói k·∫øt n·ªëi ƒë·∫øn API cleanuri: {e}", exc_info=True)
        bot.reply_to(message, f"‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• r√∫t g·ªçn link. Chi ti·∫øt: {html.escape(str(e))}")
    except json.JSONDecodeError:
        logger.error(f"L·ªói gi·∫£i m√£ JSON t·ª´ API cleanuri khi r√∫t g·ªçn link: {url_to_shorten}")
        bot.reply_to(message, "‚ùå L·ªói x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ d·ªãch v·ª• r√∫t g·ªçn link.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën trong l·ªánh /rutgon: {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën.")

@bot.message_handler(commands=['thoitiet'])
def weather_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)

    # Ki·ªÉm tra API Key
    if not WEATHER_API_KEY or WEATHER_API_KEY == "YOUR_OPENWEATHERMAP_API_KEY":
        logger.warning(f"User {user_id} d√πng /thoitiet nh∆∞ng API key ch∆∞a c·∫•u h√¨nh.")
        return bot.reply_to(message, "‚ö†Ô∏è T√≠nh nƒÉng th·ªùi ti·∫øt ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng li√™n h·ªá Admin.")

    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p t√™n th√†nh ph·ªë ho·∫∑c ƒë·ªãa ƒëi·ªÉm b·∫°n mu·ªën xem th·ªùi ti·∫øt.\nV√≠ d·ª•: <code>/thoitiet H√† N·ªôi</code>")

    location = args[1].strip()
    logger.info(f"User {user_id} ({user_name}) y√™u c·∫ßu xem th·ªùi ti·∫øt t·∫°i: '{location}'")

    # G·ªçi API OpenWeatherMap
    base_url = "http://api.openweathermap.org/data/2.5/weather?"
    complete_url = base_url + "appid=" + WEATHER_API_KEY + "&q=" + location + "&units=metric&lang=vi"

    try:
        response = requests.get(complete_url, timeout=10)
        response.raise_for_status() # Check l·ªói HTTP 4xx/5xx
        weather_data = response.json()

        # Ki·ªÉm tra m√£ ph·∫£n h·ªìi t·ª´ API (c√≥ th·ªÉ 200 nh∆∞ng v·∫´n b√°o l·ªói b√™n trong)
        if weather_data.get("cod") != 200:
             error_message = weather_data.get("message", "L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ API")
             logger.error(f"L·ªói t·ª´ API OpenWeatherMap (m√£ {weather_data.get('cod')}) cho '{location}': {error_message}")
             if "city not found" in error_message.lower():
                 return bot.reply_to(message, f"‚ùå Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm '<code>{html.escape(location)}</code>'. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n.")
             else:
                 return bot.reply_to(message, f"‚ùå L·ªói t·ª´ d·ªãch v·ª• th·ªùi ti·∫øt: {html.escape(error_message)}")

        # Tr√≠ch xu·∫•t th√¥ng tin th·ªùi ti·∫øt
        main = weather_data.get("main", {})
        weather_desc_list = weather_data.get("weather", [{}]) # L·∫•y list weather, m·∫∑c ƒë·ªãnh l√† list tr·ªëng
        weather_desc = weather_desc_list[0] if weather_desc_list else {} # L·∫•y ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n n·∫øu list kh√¥ng r·ªóng
        wind = weather_data.get("wind", {})
        sys_info = weather_data.get("sys", {})

        city_name = weather_data.get("name", location) # T√™n th√†nh ph·ªë chu·∫©n h√≥a t·ª´ API
        country = sys_info.get("country", "") # M√£ qu·ªëc gia
        temp = main.get("temp", "N/A")
        feels_like = main.get("feels_like", "N/A")
        humidity = main.get("humidity", "N/A")
        description = weather_desc.get("description", "Kh√¥ng c√≥ m√¥ t·∫£").capitalize() # M√¥ t·∫£ th·ªùi ti·∫øt, vi·∫øt hoa ch·ªØ ƒë·∫ßu
        icon_code = weather_desc.get("icon") # M√£ icon th·ªùi ti·∫øt
        wind_speed = wind.get("speed", "N/A") # T·ªëc ƒë·ªô gi√≥ (m/s v√¨ units=metric)

        # Mapping m√£ icon sang emoji (c√≥ th·ªÉ m·ªü r·ªông th√™m)
        weather_icons = {
            "01d": "‚òÄÔ∏è", "01n": "üåô", "02d": "üå§Ô∏è", "02n": "‚òÅÔ∏è",
            "03d": "‚òÅÔ∏è", "03n": "‚òÅÔ∏è", "04d": "‚òÅÔ∏è", "04n": "‚òÅÔ∏è",
            "09d": "üåßÔ∏è", "09n": "üåßÔ∏è", "10d": "üå¶Ô∏è", "10n": "üåßÔ∏è",
            "11d": "‚õàÔ∏è", "11n": "‚õàÔ∏è", "13d": "‚ùÑÔ∏è", "13n": "‚ùÑÔ∏è",
            "50d": "üå´Ô∏è", "50n": "üå´Ô∏è"
        }
        icon_emoji = weather_icons.get(icon_code, "‚ùì") # Emoji m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ icon

        # T·∫°o tin nh·∫Øn k·∫øt qu·∫£
        reply_text = (
            f"<b>Th·ªùi ti·∫øt t·∫°i {html.escape(city_name)}, {country}</b> {icon_emoji}\n"
            f"--------------------------\n"
            f"üå°Ô∏è Nhi·ªát ƒë·ªô: <b>{temp}¬∞C</b> (C·∫£m gi√°c nh∆∞: {feels_like}¬∞C)\n"
            f"üíß ƒê·ªô ·∫©m: <b>{humidity}%</b>\n"
            f"üå¨Ô∏è T·ªëc ƒë·ªô gi√≥: <b>{wind_speed} m/s</b>\n"
            f"üìù M√¥ t·∫£: <b>{html.escape(description)}</b>"
        )

        bot.reply_to(message, reply_text)
        logger.info(f"ƒê√£ g·ª≠i th√¥ng tin th·ªùi ti·∫øt cho '{location}' t·ªõi user {user_id}")

    except requests.exceptions.Timeout:
        logger.error(f"Timeout khi g·ªçi API OpenWeatherMap cho: {location}")
        bot.reply_to(message, "‚è≥ Y√™u c·∫ßu ƒë·∫øn d·ªãch v·ª• th·ªùi ti·∫øt b·ªã qu√° th·ªùi gian. Vui l√≤ng th·ª≠ l·∫°i sau.")
    except requests.exceptions.RequestException as req_err:
        logger.error(f"L·ªói k·∫øt n·ªëi ƒë·∫øn API OpenWeatherMap: {req_err}", exc_info=True)
        bot.reply_to(message, "‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• th·ªùi ti·∫øt.")
    except json.JSONDecodeError:
        logger.error(f"L·ªói gi·∫£i m√£ JSON t·ª´ API OpenWeatherMap cho: '{location}'")
        bot.reply_to(message, "‚ùå L·ªói x·ª≠ l√Ω d·ªØ li·ªáu th·ªùi ti·∫øt.")
    except IndexError:
         logger.error(f"IndexError khi x·ª≠ l√Ω d·ªØ li·ªáu th·ªùi ti·∫øt cho '{location}' (c√≥ th·ªÉ do API tr·∫£ v·ªÅ list weather r·ªóng).")
         bot.reply_to(message, "‚ùå L·ªói d·ªØ li·ªáu th·ªùi ti·∫øt kh√¥ng ƒë·∫ßy ƒë·ªß.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën trong l·ªánh /thoitiet '{location}': {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi l·∫•y th√¥ng tin th·ªùi ti·∫øt.")

@bot.message_handler(commands=['phim'])
def movie_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split(maxsplit=1)

    # Ki·ªÉm tra API Key
    if not TMDB_API_KEY or TMDB_API_KEY == "YOUR_TMDB_API_KEY":
        logger.warning(f"User {user_id} d√πng /phim nh∆∞ng API key TMDb ch∆∞a c·∫•u h√¨nh.")
        return bot.reply_to(message, "‚ö†Ô∏è T√≠nh nƒÉng t√¨m phim ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh. Vui l√≤ng li√™n h·ªá Admin.")

    if len(args) < 2 or not args[1].strip():
        return bot.reply_to(message, "‚ùå Vui l√≤ng nh·∫≠p t√™n phim b·∫°n mu·ªën t√¨m.\nV√≠ d·ª•: <code>/phim Inception</code>")

    query = args[1].strip()
    logger.info(f"User {user_id} ({user_name}) t√¨m ki·∫øm phim: '{query}'")

    search_url = f"https://api.themoviedb.org/3/search/movie"
    params = {
        "api_key": TMDB_API_KEY,
        "query": query,
        "language": "vi-VN", # ∆Øu ti√™n ti·∫øng Vi·ªát
        "include_adult": False
    }

    try:
        # B∆∞·ªõc 1: T√¨m ki·∫øm phim ƒë·ªÉ l·∫•y ID
        response_search = requests.get(search_url, params=params, timeout=10)
        response_search.raise_for_status()
        search_results = response_search.json()

        # N·∫øu kh√¥ng c√≥ k·∫øt qu·∫£ ti·∫øng Vi·ªát, th·ª≠ t√¨m ti·∫øng Anh
        if not search_results.get("results"):
            logger.info(f"Kh√¥ng t√¨m th·∫•y phim '{query}' b·∫±ng ti·∫øng Vi·ªát, th·ª≠ t√¨m b·∫±ng ti·∫øng Anh.")
            params["language"] = "en-US"
            response_search = requests.get(search_url, params=params, timeout=10)
            response_search.raise_for_status()
            search_results = response_search.json()
            # N·∫øu v·∫´n kh√¥ng c√≥ k·∫øt qu·∫£ th√¨ b√°o l·ªói
            if not search_results.get("results"):
                return bot.reply_to(message, f"‚ùå Kh√¥ng t√¨m th·∫•y phim n√†o kh·ªõp v·ªõi '<code>{html.escape(query)}</code>'.")

        # L·∫•y th√¥ng tin phim ƒë·∫ßu ti√™n trong k·∫øt qu·∫£ t√¨m ki·∫øm
        movie = search_results["results"][0]
        movie_id = movie.get("id")

        if not movie_id:
            logger.error(f"K·∫øt qu·∫£ t√¨m phim '{query}' kh√¥ng ch·ª©a ID. K·∫øt qu·∫£ ƒë·∫ßu ti√™n: {movie}")
            return bot.reply_to(message, f"‚ùå L·ªói d·ªØ li·ªáu khi t√¨m phim '<code>{html.escape(query)}</code>'.")

        # B∆∞·ªõc 2: L·∫•y chi ti·∫øt phim b·∫±ng ID (∆∞u ti√™n ti·∫øng Vi·ªát)
        details_url = f"https://api.themoviedb.org/3/movie/{movie_id}"
        details_params = {
            "api_key": TMDB_API_KEY,
            "language": "vi-VN",
            "append_to_response": "credits" # L·∫•y th√¥ng tin credits (ƒë·∫°o di·ªÖn, di·ªÖn vi√™n)
        }
        details_response_vn = requests.get(details_url, params=details_params, timeout=10)
        details = None
        # N·∫øu l·∫•y chi ti·∫øt TV th√†nh c√¥ng v√† c√≥ title th√¨ d√πng
        if details_response_vn.status_code == 200:
            details_vn = details_response_vn.json()
            if details_vn.get("title"): # ƒê√¥i khi API tr·∫£ v·ªÅ 200 nh∆∞ng n·ªôi dung r·ªóng
                details = details_vn
                logger.info(f"ƒê√£ l·∫•y chi ti·∫øt phim '{query}' (ID: {movie_id}) b·∫±ng ti·∫øng Vi·ªát.")

        # N·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c chi ti·∫øt ti·∫øng Vi·ªát, th·ª≠ l·∫•y ti·∫øng Anh
        if not details:
            logger.info(f"Kh√¥ng l·∫•y ƒë∆∞·ª£c chi ti·∫øt ti·∫øng Vi·ªát cho phim ID {movie_id}, th·ª≠ l·∫•y ti·∫øng Anh.")
            details_params["language"] = "en-US"
            details_response_en = requests.get(details_url, params=details_params, timeout=10)
            details_response_en.raise_for_status() # N·∫øu ti·∫øng Anh c≈©ng l·ªói th√¨ b√°o l·ªói lu√¥n
            details = details_response_en.json()
            logger.info(f"ƒê√£ l·∫•y chi ti·∫øt phim '{query}' (ID: {movie_id}) b·∫±ng ti·∫øng Anh.")

        # Tr√≠ch xu·∫•t th√¥ng tin chi ti·∫øt
        title = details.get("title", "N/A")
        original_title = details.get("original_title", "")
        tagline = details.get("tagline", "")
        overview = details.get("overview", "Kh√¥ng c√≥ m√¥ t·∫£.")
        release_date_str = details.get("release_date", "N/A") # d·∫°ng 'YYYY-MM-DD'
        runtime = details.get("runtime") # S·ªë ph√∫t (integer) or None
        genres_list = details.get("genres", [])
        genres = ", ".join([g["name"] for g in genres_list]) if genres_list else "N/A"
        rating = details.get("vote_average", 0) # float
        vote_count = details.get("vote_count", 0) # integer
        poster_path = details.get("poster_path") # string or None (vd: /path/to/poster.jpg)
        homepage = details.get("homepage") # string or None

        # L·∫•y th√¥ng tin ƒë·∫°o di·ªÖn v√† di·ªÖn vi√™n t·ª´ 'credits'
        director = "N/A"
        actors_list = []
        crew = details.get("credits", {}).get("crew", [])
        cast = details.get("credits", {}).get("cast", [])
        for member in crew:
            if member.get("job") == "Director":
                director = member.get("name", "N/A")
                break # L·∫•y ƒë·∫°o di·ªÖn ƒë·∫ßu ti√™n t√¨m th·∫•y
        if cast:
            actors_list = [a.get("name", "") for a in cast[:5] if a.get("name")] # L·∫•y t√™n 5 di·ªÖn vi√™n ƒë·∫ßu
        actors = ", ".join(actors_list) if actors_list else "N/A"

        # ƒê·ªãnh d·∫°ng th·ªùi l∆∞·ª£ng phim
        runtime_str = "N/A"
        if isinstance(runtime, int) and runtime > 0:
            hours = runtime // 60
            minutes = runtime % 60
            if hours > 0:
                runtime_str = f"{hours} gi·ªù {minutes} ph√∫t"
            else:
                runtime_str = f"{minutes} ph√∫t"

        # ƒê·ªãnh d·∫°ng ƒë√°nh gi√°
        rating_str = "Ch∆∞a ƒë√°nh gi√°"
        if vote_count > 0 and isinstance(rating, (float, int)) and rating > 0:
             rating_str = f"{rating:.1f}/10 ({vote_count:,} l∆∞·ª£t)" # ƒê·ªãnh d·∫°ng s·ªë vote c√≥ d·∫•u ph·∫©y

        # ƒê·ªãnh d·∫°ng ng√†y ph√°t h√†nh
        release_date_formatted = release_date_str
        try:
            if release_date_str != "N/A":
                 release_dt = datetime.strptime(release_date_str, '%Y-%m-%d')
                 release_date_formatted = release_dt.strftime('%d/%m/%Y') # ƒê·ªïi sang DD/MM/YYYY
        except ValueError:
             pass # Gi·ªØ nguy√™n chu·ªói g·ªëc n·∫øu kh√¥ng parse ƒë∆∞·ª£c

        # Escape HTML c√°c tr∆∞·ªùng vƒÉn b·∫£n
        safe_title = html.escape(title)
        safe_original_title = html.escape(original_title) if original_title else ""
        safe_tagline = html.escape(tagline) if tagline else ""
        safe_genres = html.escape(genres)
        safe_director = html.escape(director)
        safe_actors = html.escape(actors)
        safe_overview = html.escape(overview or 'Ch∆∞a c√≥ m√¥ t·∫£.')

        # T·∫°o caption
        caption_lines = []
        caption_lines.append(f"üé¨ <b>{safe_title}</b>")
        if safe_original_title and safe_original_title != safe_title:
            caption_lines.append(f"   <i>(T√™n g·ªëc: {safe_original_title})</i>")
        if safe_tagline:
            caption_lines.append(f"   <i>‚Äú{safe_tagline}‚Äù</i>")
        caption_lines.append("--------------------------")
        caption_lines.append(f"‚≠êÔ∏è ƒê√°nh gi√°: <b>{rating_str}</b>")
        caption_lines.append(f"üóìÔ∏è Ph√°t h√†nh: {release_date_formatted}")
        caption_lines.append(f"‚è±Ô∏è Th·ªùi l∆∞·ª£ng: {runtime_str}")
        caption_lines.append(f"üé≠ Th·ªÉ lo·∫°i: {safe_genres}")
        caption_lines.append(f"üé¨ ƒê·∫°o di·ªÖn: {safe_director}")
        caption_lines.append(f"üë• Di·ªÖn vi√™n: {safe_actors}")
        caption_lines.append("--------------------------")

        # Gi·ªõi h·∫°n ƒë·ªô d√†i t√≥m t·∫Øt
        max_overview_length = 350 # Gi·ªõi h·∫°n ƒë·ªÉ caption kh√¥ng qu√° d√†i
        if len(safe_overview) > max_overview_length:
            safe_overview = safe_overview[:max_overview_length] + "..."

        caption_lines.append(f"üìù <b>N·ªôi dung:</b>\n{safe_overview}")
        if homepage:
            caption_lines.append(f"\nüîó Trang ch·ªß: {homepage}")

        caption = "\n".join(caption_lines)

        # G·ª≠i k·∫øt qu·∫£ (c√≥ ·∫£nh n·∫øu t√¨m th·∫•y poster)
        if poster_path:
            poster_url = f"https://image.tmdb.org/t/p/w500{poster_path}" # w500 l√† k√≠ch th∆∞·ªõc ·∫£nh
            try:
                # Telegram gi·ªõi h·∫°n caption ·∫£nh l√† 1024 k√Ω t·ª±
                max_caption_length = 1024
                if len(caption) > max_caption_length:
                    caption = caption[:max_caption_length-25] + "...\n(N·ªôi dung b·ªã c·∫Øt b·ªõt)"

                bot.send_photo(
                    message.chat.id,
                    photo=poster_url,
                    caption=caption,
                    reply_to_message_id=message.message_id
                )
                logger.info(f"ƒê√£ g·ª≠i th√¥ng tin phim '{title}' k√®m poster cho user {user_id}")
            except Exception as img_err:
                logger.warning(f"L·ªói khi g·ª≠i ·∫£nh poster phim '{title}': {img_err}. S·∫Ω g·ª≠i d·∫°ng vƒÉn b·∫£n.")
                # G·ª≠i d·∫°ng vƒÉn b·∫£n n·∫øu g·ª≠i ·∫£nh l·ªói
                bot.reply_to(message, caption, disable_web_page_preview=True)
        else:
            # G·ª≠i d·∫°ng vƒÉn b·∫£n n·∫øu kh√¥ng c√≥ poster
            bot.reply_to(message, caption, disable_web_page_preview=True)
            logger.info(f"ƒê√£ g·ª≠i th√¥ng tin phim '{title}' (kh√¥ng c√≥ poster) cho user {user_id}")

    except requests.exceptions.Timeout:
        logger.error(f"Timeout khi g·ªçi API TMDb cho phim: {query}")
        bot.reply_to(message, "‚è≥ Y√™u c·∫ßu ƒë·∫øn d·ªãch v·ª• t√¨m phim b·ªã qu√° th·ªùi gian. Vui l√≤ng th·ª≠ l·∫°i sau.")
    except requests.exceptions.RequestException as req_err:
        logger.error(f"L·ªói k·∫øt n·ªëi ƒë·∫øn API TMDb: {req_err}", exc_info=True)
        bot.reply_to(message, "‚ùå L·ªói k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• t√¨m phim.")
    except json.JSONDecodeError:
        logger.error(f"L·ªói gi·∫£i m√£ JSON t·ª´ API TMDb khi t√¨m phim: '{query}'")
        bot.reply_to(message, "‚ùå L·ªói x·ª≠ l√Ω d·ªØ li·ªáu phim.")
    except IndexError:
         logger.warning(f"IndexError khi x·ª≠ l√Ω k·∫øt qu·∫£ t√¨m phim '{query}' (c√≥ th·ªÉ do k·∫øt qu·∫£ r·ªóng sau khi l·ªçc).")
         bot.reply_to(message, f"‚ùå Kh√¥ng t√¨m th·∫•y chi ti·∫øt cho phim '<code>{html.escape(query)}</code>' ho·∫∑c d·ªØ li·ªáu tr·∫£ v·ªÅ kh√¥ng h·ª£p l·ªá.")
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën trong l·ªánh /phim '{query}': {e}", exc_info=True)
        bot.reply_to(message, "‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi t√¨m th√¥ng tin phim.")

@bot.message_handler(commands=['admin'])
def admin_contact_command(message: telebot.types.Message):
     user_id, user_name = get_user_info_from_message(message)
     bot.reply_to(message, f"üßë‚Äçüíº N·∫øu b·∫°n c·∫ßn h·ªó tr·ª£ ho·∫∑c c√≥ th·∫Øc m·∫Øc, vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n: @{ADMIN_USERNAME}")
     logger.info(f"User {user_id} ({user_name}) y√™u c·∫ßu th√¥ng tin li√™n h·ªá admin.")

# === C√ÅC L·ªÜNH SPAM M·ªöI ===

def run_spam_script(phone_number: str, count: int, message: telebot.types.Message) -> bool:
    """H√†m helper ƒë·ªÉ ch·∫°y script spam v√† x·ª≠ l√Ω k·∫øt qu·∫£."""
    script_path = BASE_DIR / SPAM_SCRIPT_NAME
    if not script_path.exists():
        logger.error(f"L·ªói: Script spam '{SPAM_SCRIPT_NAME}' kh√¥ng t√¨m th·∫•y t·∫°i '{script_path}'.")
        bot.reply_to(message, f"‚ùå L·ªói h·ªá th·ªëng: Kh√¥ng t√¨m th·∫•y c√¥ng c·ª• spam. Vui l√≤ng li√™n h·ªá Admin (@{ADMIN_USERNAME}).")
        return False

    command = ['python', str(script_path), phone_number, str(count)]
    try:
        logger.info(f"ƒêang ch·∫°y script spam: {' '.join(command)}")
        # G·ª≠i tin nh·∫Øn ch·ªù
        waiting_msg = bot.reply_to(message, f"‚è≥ ƒêang b·∫Øt ƒë·∫ßu g·ª≠i <b>{count}</b> tin nh·∫Øn ƒë·∫øn <code>{html.escape(phone_number)}</code>... Vui l√≤ng ch·ªù.")

        # Ch·∫°y script trong n·ªÅn v·ªõi timeout
        result = subprocess.run(command, capture_output=True, text=True, timeout=SPAM_TIMEOUT, check=False) # check=False ƒë·ªÉ kh√¥ng n√©m l·ªói n·∫øu script th·∫•t b·∫°i

        # X√≥a tin nh·∫Øn ch·ªù
        try:
            bot.delete_message(chat_id=waiting_msg.chat.id, message_id=waiting_msg.message_id)
        except Exception:
            pass # B·ªè qua n·∫øu kh√¥ng x√≥a ƒë∆∞·ª£c

        # X·ª≠ l√Ω k·∫øt qu·∫£
        if result.returncode == 0:
            logger.info(f"Script spam cho SƒêT {phone_number} ho√†n th√†nh th√†nh c√¥ng. Output:\n{result.stdout}")
            bot.reply_to(message, f"‚úÖ ƒê√£ g·ª≠i th√†nh c√¥ng <b>{count}</b> tin nh·∫Øn ƒë·∫øn <code>{html.escape(phone_number)}</code>.")
            return True
        else:
            logger.error(f"Script spam cho SƒêT {phone_number} th·∫•t b·∫°i (return code {result.returncode}).\nStderr: {result.stderr}\nStdout: {result.stdout}")
            error_details = f"Chi ti·∫øt l·ªói (n·∫øu c√≥): {html.escape(result.stderr.strip() or result.stdout.strip() or 'Kh√¥ng c√≥ output c·ª• th·ªÉ')}"
            bot.reply_to(message, f"‚ùå G·ª≠i tin nh·∫Øn ƒë·∫øn <code>{html.escape(phone_number)}</code> th·∫•t b·∫°i.\n{error_details[:1000]}") # Gi·ªõi h·∫°n ƒë·ªô d√†i l·ªói
            return False

    except FileNotFoundError:
        logger.error(f"L·ªói: L·ªánh 'python' kh√¥ng t√¨m th·∫•y ho·∫∑c script '{SPAM_SCRIPT_NAME}' kh√¥ng t·ªìn t·∫°i.")
        bot.reply_to(message, f"‚ùå L·ªói h·ªá th·ªëng: Kh√¥ng th·ªÉ th·ª±c thi c√¥ng c·ª• spam. Vui l√≤ng li√™n h·ªá Admin (@{ADMIN_USERNAME}).")
        return False
    except subprocess.TimeoutExpired:
        logger.error(f"Script spam cho SƒêT {phone_number} b·ªã timeout sau {SPAM_TIMEOUT} gi√¢y.")
        bot.reply_to(message, f"‚è≥ Qu√° tr√¨nh g·ª≠i tin nh·∫Øn ƒë·∫øn <code>{html.escape(phone_number)}</code> m·∫•t qu√° nhi·ªÅu th·ªùi gian v√† ƒë√£ b·ªã d·ª´ng.")
        return False
    except Exception as e:
        logger.error(f"L·ªói kh√¥ng mong mu·ªën khi ch·∫°y script spam cho SƒêT {phone_number}: {e}", exc_info=True)
        bot.reply_to(message, f"‚ùå ƒê√£ x·∫£y ra l·ªói kh√¥ng mong mu·ªën khi th·ª±c hi·ªán l·ªánh spam: {html.escape(str(e))}")
        return False

@bot.message_handler(commands=['spam'])
def spam_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)
    args = message.text.split()

    # --- Ki·ªÉm tra c√∫ ph√°p ---
    if len(args) != 3:
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! V√≠ d·ª•: <code>/spam 09xxxxxxxx 5</code>\n(T·ªëi ƒëa {SPAM_FREE_MAX_COUNT} tin, cooldown {SPAM_FREE_COOLDOWN}s)")

    phone_number = args[1].replace('+', '').replace(' ', '').strip()
    count_str = args[2]

    # --- Validate Input ---
    if not phone_number.isdigit():
        return bot.reply_to(message, "‚ùå S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá (ch·ªâ ch·ª©a s·ªë).")

    if phone_number in BLACKLISTED_NUMBERS:
        return bot.reply_to(message, f"üö´ S·ªë ƒëi·ªán tho·∫°i <code>{html.escape(phone_number)}</code> n·∫±m trong danh s√°ch c·∫•m.")

    try:
        count = int(count_str)
        if not (0 < count <= SPAM_FREE_MAX_COUNT):
            return bot.reply_to(message, f"‚ö†Ô∏è S·ªë l∆∞·ª£ng tin nh·∫Øn ph·∫£i t·ª´ 1 ƒë·∫øn {SPAM_FREE_MAX_COUNT}.")
    except ValueError:
        return bot.reply_to(message, "‚ö†Ô∏è S·ªë l∆∞·ª£ng tin nh·∫Øn kh√¥ng h·ª£p l·ªá (ph·∫£i l√† s·ªë).")

    # --- Ki·ªÉm tra Cooldown ---
    command_name = 'spam_free' # D√πng t√™n ri√™ng cho cooldown free
    current_time = time.time()
    user_last_cmd_times = last_command_time.setdefault(user_id, {})
    last_spam_time = user_last_cmd_times.get(command_name, 0)

    if current_time - last_spam_time < SPAM_FREE_COOLDOWN:
        wait_time = round(SPAM_FREE_COOLDOWN - (current_time - last_spam_time), 1)
        msg_wait = bot.reply_to(message, f"‚è≥ B·∫°n v·ª´a s·ª≠ d·ª•ng l·ªánh n√†y! Vui l√≤ng ch·ªù <b>{wait_time} gi√¢y</b> n·ªØa.")
        delete_message_after_delay(message.chat.id, msg_wait.message_id, wait_time + 1)
        delete_message_after_delay(message.chat.id, message.message_id, wait_time + 1)
        return

    # --- Th·ª±c hi·ªán Spam ---
    logger.info(f"User {user_id} ({user_name}) y√™u c·∫ßu /spam: SƒêT={phone_number}, Count={count}")
    success = run_spam_script(phone_number, count, message)

    if success:
        # C·∫≠p nh·∫≠t th·ªùi gian cooldown ch·ªâ khi th·ª±c hi·ªán th√†nh c√¥ng (ho·∫∑c √≠t nh·∫•t l√† ƒë√£ ch·∫°y script)
        user_last_cmd_times[command_name] = current_time

@bot.message_handler(commands=['spamvip'])
def spamvip_command(message: telebot.types.Message):
    user_id, user_name = get_user_info_from_message(message)

    # --- Ki·ªÉm tra VIP ---
    if user_id not in allowed_vip_users:
        # C√≥ th·ªÉ ki·ªÉm tra c·∫£ expiration_time ·ªü ƒë√¢y n·∫øu mu·ªën ch·∫Øc ch·∫Øn h∆°n
        # expiration_time = get_vip_expiration_time_from_db(user_id)
        # if not expiration_time or expiration_time <= datetime.now():
        return bot.reply_to(message, "‚õî L·ªánh n√†y ch·ªâ d√†nh cho th√†nh vi√™n VIP! S·ª≠ d·ª•ng /muavip ƒë·ªÉ ƒëƒÉng k√Ω.")

    args = message.text.split()

    # --- Ki·ªÉm tra c√∫ ph√°p ---
    if len(args) != 3:
        return bot.reply_to(message, f"‚ùå Sai c√∫ ph√°p! V√≠ d·ª•: <code>/spamvip 09xxxxxxxx 20</code>\n(T·ªëi ƒëa {SPAM_VIP_MAX_COUNT} tin)")

    phone_number = args[1].replace('+', '').replace(' ', '').strip()
    count_str = args[2]

    # --- Validate Input ---
    if not phone_number.isdigit():
        return bot.reply_to(message, "‚ùå S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá (ch·ªâ ch·ª©a s·ªë).")

    if phone_number in BLACKLISTED_NUMBERS:
        return bot.reply_to(message, f"üö´ S·ªë ƒëi·ªán tho·∫°i <code>{html.escape(phone_number)}</code> n·∫±m trong danh s√°ch c·∫•m.")

    try:
        count = int(count_str)
        if not (0 < count <= SPAM_VIP_MAX_COUNT):
            return bot.reply_to(message, f"‚ö†Ô∏è S·ªë l∆∞·ª£ng tin nh·∫Øn ph·∫£i t·ª´ 1 ƒë·∫øn {SPAM_VIP_MAX_COUNT}.")
    except ValueError:
        return bot.reply_to(message, "‚ö†Ô∏è S·ªë l∆∞·ª£ng tin nh·∫Øn kh√¥ng h·ª£p l·ªá (ph·∫£i l√† s·ªë).")

    # --- Th·ª±c hi·ªán Spam (Kh√¥ng Cooldown cho VIP) ---
    logger.info(f"VIP User {user_id} ({user_name}) y√™u c·∫ßu /spamvip: SƒêT={phone_number}, Count={count}")
    run_spam_script(phone_number, count, message)
    # Kh√¥ng c·∫ßn c·∫≠p nh·∫≠t last_command_time cho VIP spam

# === Kh·ªüi ch·∫°y Bot ===
def main():
    logger.info("--- Bot ƒëang kh·ªüi t·∫°o ---")
    # Kh·ªüi t·∫°o database v√† load d·ªØ li·ªáu ban ƒë·∫ßu
    initialize_vip_database()
    load_vip_users_from_db()
    _ = load_game_data_sync() # Load th·ª≠ ƒë·ªÉ ƒë·∫£m b·∫£o file kh√¥ng l·ªói, kh√¥ng c·∫ßn l∆∞u k·∫øt qu·∫£ ·ªü ƒë√¢y

    logger.info(f"Bot Token: ...{BOT_TOKEN[-6:]}")
    logger.info(f"Admin ID: {ADMIN_ID} | Admin Username: @{ADMIN_USERNAME}")
    logger.info(f"Game Data File: {DATA_FILE_PATH}")
    logger.info(f"VIP DB File: {DB_FILE_PATH}")
    logger.info(f"VIP QR Code Image: {QR_CODE_IMAGE_PATH}")
    logger.info(f"Spam Script: {SPAM_SCRIPT_NAME}")
    logger.info(f"Bot b·∫Øt ƒë·∫ßu ch·∫°y l√∫c: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    logger.info("--- Bot ƒë√£ s·∫µn s√†ng nh·∫≠n l·ªánh ---")

    try:
        # B·∫Øt ƒë·∫ßu l·∫Øng nghe tin nh·∫Øn t·ª´ Telegram
        # logger_level=logging.INFO ƒë·ªÉ th·∫•y log c·ªßa th∆∞ vi·ªán telebot
        # skip_pending=True ƒë·ªÉ b·ªè qua c√°c tin nh·∫Øn c≈© khi bot offline
        bot.infinity_polling(logger_level=logging.WARNING, skip_pending=True) # Gi·∫£m log c·ªßa telebot xu·ªëng WARNING
    except Exception as e:
        # Log l·ªói nghi√™m tr·ªçng khi·∫øn bot d·ª´ng
        logger.critical(f"!!! L·ªñI NGHI√äM TR·ªåNG KHI·∫æN BOT D·ª™NG HO·∫†T ƒê·ªòNG: {e}", exc_info=True)
    finally:
        # Th√¥ng b√°o khi bot d·ª´ng (d√π do l·ªói hay d·ª´ng th·ªß c√¥ng)
        logger.info("--- Bot ƒëang d·ª´ng... ---")
        # C√≥ th·ªÉ th√™m c√°c h√†nh ƒë·ªông d·ªçn d·∫πp ·ªü ƒë√¢y n·∫øu c·∫ßn
        logger.info("--- Bot ƒë√£ d·ª´ng ho√†n to√†n ---")

if __name__ == '__main__':
    main()
